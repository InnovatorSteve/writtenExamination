# C++基础

## 关键字

### explicit

指定构造函数或者转换函数为显示，禁止隐式转换和[复制初始化](https://www.cnblogs.com/cposture/p/4925736.html#:~:text=%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%B7%E8%B4%9D,%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%82)(将已有的对象拷贝到正在创建的对象)。

构造函数尽量使用explicit。(如果我们能预料某种情况的发生，就不要把这个情况的控制权交给编译器)。

可以防止隐式转换，但是按语境转换除外。

按语境转换：期待类型 bool，且如果声明 bool t(e); 良构就会进行隐式转换（即考虑如 `explicit T::operator bool() const;` 这样的隐式转换函数）。称这种表达式 `e` 按语境转换到 `bool`。

```cpp
按语境转换
struct B{
	explicit B(int) {}
    explicit operator bool() const {return true;}
}
B b1(1);
if(b1);
bool b2(b1); //这两个都是按语境转换  是可以的
```

被explict不可以被复制初始化。 形如B b2 = 1,或 B b3 = {1};

### voilte

提醒编译器它所定义的变量可能随时改变，每次存储或者读取的时候，直接从变量地址读取，如果没有voilte关键字的话，编译器可能优化读取和存储，可能暂时使用寄存器的值，可能存在实际值与读取的到值不一致的情况。

### sizeof与strlen

sizeof是运算符不是函数。

```  cpp
    char str[20] = "abcdefg"; 
    char *s = (char *)malloc(20); 
    // strcpy(s, str); 
    printf("%d %d %d %d\n",strlen(str), sizeof(str), strlen(s),sizeof(s);
  //7 20 随机 4    strlen是遇到\0结束，而s未初始化申请内存，所以结果随机位置，而sizeof(s) 求的为指针大小 4字节
```

### C++ 新特性

auto decltype  using 列表初始化  lambda  for(autp& : )  右值引用 移动构造 move 完美转发 智能指针  并发 线程 互斥锁等  继承构造函数  

#### 关键字

##### atomic

atomic对int、char、bool等数据结构进行了原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。

所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。

##### final  

卸载类名后 表示类不允许被继承

##### override

动机：子类中同名函数无需申明virtual也是虚函数，带来问题是：阅读性变差，无法只管确定是否为重写父类函数。子类如果不小心写错函数签名(函数名，参数类型，参数个数等)，就会变成独立的方法。

override 声明为重写父类同名方法，如果父类不存在就会报错。

##### default

不提供任何构造函数时，会使用编译器提供的默认构造函数，提供一个有参构造函数时，编译器不再提供无参构造、拷贝构造等。但是可以通过

A() = default;  让编译器提供无参构造。  强制让编译器生成构造函数、析构函数、拷贝构造函数等。

##### delete

可以使用  A() = delete；  禁止使用A的无参构造函数。

### C++17

结构化绑定

示例：vector<pair<int, int>> vec; auto [a, b] = vec[0];



### 类关键字

### new delete malloc free

规则：

- new/delete是关键字，效率高于malloc和free
- 配对使用，避免内存泄露和多重释放。
- 避免交叉使用，比如malloc申请使用delete释放。
- new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理

区别：

- 属性：new/delete是关键字需要编译器支持，而malloc是库函数，需要头文件支持(stdlib.h)。
- 参数：new操作符申请无需指定内存块的大小，编译器会自动计算，而malloc需要显式的指出所需内存大小。
- 返回值：new成功后返回对象类型的指针，类型严格与对象匹配，new是类型安全的操作。而malloc返回的是void*，需要强制类型转换成我们需要的类型。
- 自定义类型：new会调用类型的构造函数，初始化成员变量，返回自定义类型指针，delete先调用析构函数，然后调用operator delete函数释放内存(底层free实现)。malloc/free是库函数，只能动态申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。(new C++  malloc C 对象 C++)
- C++允许重载operator new 和operator delete函数控制动态内存的分配。
- 存储位置：new从自由存储区(free store)上为对象动态分配内存空间，而malloc从堆上动态分配内存。自由存储区是C++的抽象概念，自由存储区取决于operator new实现细节，可以是堆，还可以是静态存储区。
- new内存分配失败，抛出异常，不会返回null(try catch)，而malloc内存分配失败时返回null(if null)
- 对于数组的处理，可以用new[]  malloc需要手动给定 分配。
- 重新分配内存：malloc可以调用realloc进行内存重分配实现内存的扩充(拷贝到新的)， new不支持。

malloc不是内存的终极管理者，最大能过够申请内存空间，受机器的bit数(寻址空间)，操作系统策略，实际可用资源量，malloc本身算法制约，应用程序申请方式和次数的制约等。在32位下尝试，分配到1.9G左右。

malloc底层实现：小于128k时调用brk()函数，大于时调用mmap() (地址的映射)，内存池的管理方式，一检查内粗你碎片。

new底层实现：创建一个新的对象。构造函数的作用域赋值给这个对象。执行构造函数的代码。返回对象。

#### 内存申请相关函数

- alloca()向栈申请内存，无需释放。

- void* malloc(unsgined size)分配的内存位于堆中，而且没有初始化内容，申请内存是没有类型的,因此需要memst来初始化空间。

- void* calloc(size_t numElements, size_t sizeOfElement)；堆中分配n块长度为sizeOf Elemenet字节的连续区域，自动将申请的内存空间初始化为零。

- void* realloc()则对申请的内存大小进行调整。

  注意： char* p = malloc(1024); char* q = malloc(2048)。

  - 当前连续内存足够realloc的话，只是将p所指向的空间扩大，并返回p的指针地址。
  - 当前连续内存不够申请的话，再找一个长度足够的地方，分配一个块新的内存q，并将p指向的内容copy到q，返回q。并将所指向的内存空间删除。

### const

- 定义为常量，不可变性
- 节省空间，const常量在程序运行中只有一份拷贝。而#define定义的常量在内存中有若干个复制品。
- 提高程序运行效率，编译器不为const常量分配存储空间，而是将他们保存在符号表中，没有了存储和读取的操作。
- 类成员函数指定为const类型，标明为常函数，不能修改类的成员变量。
- 指定返回值类型为const类型，使其返回值不为左值。

###  typedef

```cpp
typedef typename std::vector<T>::size_type size_type;
```

C++语言默认情况下，假定通过作用域运算符访问的名字不是类型，所以当我们要访问的是类型时候，必须显示的告诉编译器这是一个类型，通过关键字typename来实现这一点

typedef 类型 定义名;

类型说明只定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。typedef同样可用来说明结构、联合以及枚举和类.

### #define

#代表预处理命令，在编译器进行编译前对源代码做某些转换。

C语言中可以使用#define定义一个标识符来表示一个常量,其特点是:定义的标识符不占内存,只是一个临时的符号,预编译后这个符号就不存在了.

> C语言程序从编写到运行需要经过预处理,编译,汇编,链接四个阶段. 前四个阶段又统称为编译.

1. **无参宏定义 #define 标识符 字符串**  简单替换， \#define M (a+b)
2. **带参宏定义 \#define 宏名(形参表) 字符串**   \#define MAX(a,b) (a>b)?a:b
3. \#把宏参数变为一个字符串, 用##把两个宏参数贴合在一起
4. #a  替换为 'a'     a##b 替换为 ab
5. 当宏参数是另一个宏的时候，需要注意的是凡宏定义里有用’#’或’##’的地方宏参数是不会再展开.  再加一个中间宏定义即可
6. 其实预编译所执行的操作就是简单的“文本”替换。
7. 函数定义：**#define xxx() ({})**  \#define A(a,b,c) ({a=1;b+=1;c=3;a+b+c;})    a+b+c;是返回值

\#define MOD(X, Y) X % Y    MOD(67 + 5 , 3 + 9) * 4 =   67 + 5 % 3 + 9 * 4.

### static

1.static局部变量

- 定义局部变量的生存周期为整个程序的生命周期，但是其作用域仍与自动变量相同。出了作用域，不能使用，虽然还存在。
- 对基本类型的静态局部变量若在声明时未予赋值，则系统自动赋予0值，而未赋值的自动变量的初值是未知的。
- static局部变量只会在第一被调用时执行。

2.static全局变量

- 非静态全局变量的作用域是整个源程序。
- 静态全局变量只在定义该变量的源文件内有效。避免在其他源文件中引起错误。

3.static函数

- 使函数的作用域仅限本文件，避免了与其他文件中的函数重名。

4.static成员变量

- 对于非static成员变量，每个类对象都有自己的拷贝。而static成员数据被当作类成员，所有对象共享一份数据。
- 静态数据成员存储在全局区，静态数据成员在定义时才分配空降空间，所以必须在类外初始化。
- 可以在有或者没有实例化对象的时候，都可以通过类名操作它。(Myclass.num或Myclass::num)
- 同全局变量相比，优势在于：
  - 静态成员数据没有进入程序的全局名字空间，不会与其他全局名字引发冲突。
  - 可以用private实现信息隐藏，而全局变量不能。

5.static成员函数

- 类体外，静态函数的实现体前不能加static。
- static成员之间可以相互访问。包括static成员函数访问static数据成员或者static成员函数。
- 非静态成员函数可以任意访问静态成员函数和静态数据成员。
- 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的。因为没有this。
- 可以通过成员访问操作符"."和"->"或者直接类名调用静态成员函数。

### inline

内联函数与宏函数对比

优点：

- 内联函数同宏函数一样在被调用出进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高了程序运行效率。
- 内敛函数会进行安全检查或自动类型转换(同普通函数)，而宏定义不会。
- 在类中声明同时定义的成员函数，会自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义不能。
- 内联函数在运行时可以调试，而宏定义不可以。

缺点：

- 代码膨胀。尤其是在执行函数体内代码时间相比函数调用开销较大，那么效率时低下的。代码膨胀会导致额外的换页行为，降低指令高速缓存的命中率。
- inline函数无法随着函数库升级而升级，需要重新编译。
- 是否内联，程序员不可控。只是给编译器的建议。

构造、析构函数可以为内联函数吗？

从语法上没有错误，但是从实际意义上讲，不建议。因为编译器会给构造函数和析构函数加入很多的代码，不适合作为内联函数。编译器也不会真正区内连。

虚函数可以时内联函数吗？

- 虚函数可以是内联函数，但是虚函数表现为多态性的时候不能内联。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期间，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。
- inline virtual唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如：Base:who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。



### 不常用关键字 位域等

#### assert()

assert()，断言，是宏，而非函数。作用是如果它的条件返回错误，则终止程序运行。可以通过NODEBUG关闭，需要在#include<assert.h>之前加上#define NODEBUG

#### 位域

动机：有些数据在存储时并需要占用一个完整的字节，只需要占用一个或几个二进制位即可。

定义：把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，运行在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位表示。

```cpp
//定义形式
struct 位域结构名{
	type member_name : width; //位域列表
};
```

位域列表中变量元素的描述：

|    元素     |                             描述                             |
| :---------: | :----------------------------------------------------------: |
|    type     | 只能位int、unsigned int、signe int三种类型，决定了如何解释位域的值 |
| member_name |                          位域的名称                          |
|    width    |      位域中位的数量，宽度必须小于或等于指定类型的位宽度      |

带有预定义宽度的变量被称为**位域**。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：

```cpp
struct Age{ 
    unsigned int age : 3;
} Age1;
```

注意：位域定义由结构体实现，所以同样遵循4字节对齐原则。

位域可以将（非静态）数据成员定义为位域。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常用到位域。

- 位域在内存中的布局是跟机器有关的。
- 位于的类型必须是整形或者枚举类型，带符号类中的位域行为将因具体实现而定。
- 取地址符&不能用于位域，任何指针无法指向类的位域。

#### decltype 声明类型

有了auto引入decltype得原因是有些情况下atuo使用不便甚至无法使用。

类型推导符：decltype关键字用于检查实体的声明类型或表达式的类型及值分类。

注意：exp的结果不能为void

decltype推导规则：

- 如果exp是一个不被()包裹的表达式，或是一个类成成员的访问表达式(Student::total)，或是一个变量，那么decltype(exp)类型就和exp一样。
- exp是函数调用，decltype(exp)类型和函数返回值的类型一致。需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。
- exp是左值，或被()包围，那么decltype(exp)类型就是exp的引用。假设exp类型为T，decltype(exp)类型的类型为&T。

```cpp
 	//带有括号的表达式
    decltype(obj.x) a = 0;  //obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
    decltype((obj.x)) b = a;  //obj.x 带有括号，符合推导规则三，b 的类型为 int&。
    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;  //n+m 得到一个右值，符合推导规则一，所以推导结果为 int
    decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&

    atuo varname = value;
    decltype(exp) varname = value;           decltype根据exp表达式推出变量的类型 给varname赋为响应的类型。
//  区别：decltype可以不初始化 写为： decltype(exp) varname;  

template<typename It>
auto fcn(It beg, It end) ->decltype(*beg){ //配合auto使用 允许在参数列表之后返回类型,用于动态确定返回值类型
	return *beg;    
}
//为了使用模板参数成员，必须使用typename  指出这是一个类型
template <typename It>
auto fcn2(It beg, It eng)->typename remove_reference<decltype(*beg)>::type{
    return *beg;
}
```

要推到非静态成员类型必须使用decltype。

### extern "c"

- 被extern限定的函数或变量是extern类型的。其申明的函数和变量可以在本模块或其他模块中使用。
- 被extern "c"修饰的变量和函数是按照C语言方式编译和链接的。

编译区别：由于C++支持函数重载，因此编译器编译函数的过程会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名。C无重载，编译的时候只有函数名。

### 类型 关键字 size_t

size_t 可能会提高代码的可移植性、有效性或者可读性，或许同时提高这三者.

size_t类型是一个类型定义，通常将一些无符号的整形定义为size_t，比如说unsigned int或者unsigned 
long，甚至unsigned long long。每一个标准C实现应该选择足够大的无符号整形来代表该平台上最大可能出现的对象大小。

size_t 代表字节大小或数组索引

### struct和typedef struct，以及class区别

总结

- struct一般用于描述一个数据结构的集合，而class是对一个对象数据的封装。
- struct默认继承权限是public，class默认继承权限是private，但是应该明确指出而不是靠默认。
- struct数据访问默认权限是public，class数据访问默认权限是private。
- class可用于定义模板参数，同"typename"

C与C++ struct的区别：

- C的struct不能有成员函数、静态成员，访问控制默认public(不能修改)，不可以继承，不能直接初始化数据成员。
- C++的Struct可以有成员函数、静态成员，访问控制默认public(可以修改)，可以继承，可以直接初始化数据成员。
- C中使用结构体要加上struct关键字，或者使用typedef起别名，而C++可以省略struct使用(前提是没有同名函数)。

### union

定义：联合(union)是一种节省空间的特殊的类，一个union可以有多个数据成员，但是在任意时刻只有一个数据成员有值。当某个成员被定义后其他成员变为未定义状态。有以下特点：

- 默认访问控制符为pulic
- 可有含有构造函数和析构函数
- 不能含有引用的类
- 不能继承自其他类，也不能作为基类
- 不能含有虚函数(因为没有继承)
- 匿名union在定义所在作用域可直接访问union成员
- 匿名union不能包含protected成员或private成员
- 全局匿名联合必须是静态的

``` cpp 
//union的使用
union UnionTest{
	UnionTest() : i(10) {};
    int i;
    double d;
};
static union{ //全局匿名联合必须是静态的
	int i;
    double d;
};
int main(){
    Union u;
    union{
		int i;
        double d;
    }
    std::cout << u.i << std::endl; //输出UnionTest联合的10
    ::i = 20;
    std::cout << ::i << std:: endl;  //输出全局静态匿名联合的20
    i = 30;
    std::cout << i << std::endl; //输出局部匿名联合的30
    return 0;
}

union uniA {int a; char b[2];}  //联合以最长数据为准，这里是四个字节。
union uniA A; A.a = 256;  内存布局为 00 01 00 00  A.b[1] = 2; 内存为 00 02 00 00 A.b[0] = '0'; 内存为 30 02 00 00  A.a = 560
```



### using和范围解析附::

#### using注意事项：

- 尽量少使用using指示  using namespace std；
- 多使用using声明 std::cout 或者 using std::cout

#### 范围解析符

分类：

- 全局作用域符(::name):用于类型名(类、成员、成员函数、变量等)前，表示作用域为全局命名空间。

  使用场景：例：全局变量与局部变量命名相同，在局部内直接调用的为局部变量，可以加上::调用全局变量。

- 类作用域符(class::name)：用于表示指定类型的作用域范围是具体某个类的。

- 命名空间作用域符(namespace::name)：用于表示指定类型的作用域是某个具体命名空间的。

### 成员初始化列表

好处：更高效，少了一次调用默认构造函数的过程。

有些场景必须使用初始化列表：

- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表中。
- 引用类型，引用必须在定义时初始化，并且不能重新赋值。
- 没有默认构造函数的类型，因为使用初始化列表可以不调用默认构造函数来初始化。

**initializer_list**

定义在头文件\<initializer_list>中，用于表示某种特定类型的值的数组。

```cpp
std::vector<int> v = {1, 2, 3, 4, 5}; //内部实现就用到二零initializer_list
//还允许我们在构造函数或其他函数中把初始化列表当作参数
class Myclass{
Myclass(const std::initializer_list<int> &v){
    for(auto it : v)
        	mVec.push_back(it);
}
std::vecotr<int> mVec;
};
```

需要注意的是，initializer_list对象元素中的值是常量，无法改变，拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素，只是引用。

### 强制类型转换运算符

强制类型转换容易引发错误，所以被认为是一种丑陋的语法。C++中有一个观念：丑陋的语法就应该用丑陋的方式表达。所以，C++的转换操作符使用xxxx_cast<...>()这种一种繁琐的形式。目的是为了让你在使用类型转换前三思而行，看看是不是又不需要类型转换的方法或设计。 C风格的转换不容易查找，这在debug时是令人头疼的。各种类型转换差别较大，具体细化，交给特定函数去完成，效率高，更安全。

#### static_cast

- 用于非多态类型的转换。
- 不执行转换时的类型检查(安全性不如dynamic_cast)。
- 通常用于数据类型转换(如float->int)。
- 可以在整个类层次结构中移动指针，子类转化为父类安全(向上转换)，父类转化为子类不安全(因为子类可能含有父类没有的字段或者方法)。向上转换是一种隐式转换。

#### dynamic_cast

- 用于多态类型的转换。
- 执行运行时类型检查。
- 只适用于指针或者引用。
- 对不明确的指针的转换将失败(返回nullptr)，但是不引发异常。
- 可以在整个层次类中移动指针，包括向上转换，向下转换。

#### const_cast

用于删除const、volatile和_unaligned(用于字节对齐)特性。

> 结构体总大小为结构体最宽基本类型成员大小的整数倍。
>
> 如果嵌套的有结构体，在字节对齐时，根据嵌套结构体内的数据成员的最宽基本类型算，是打散开看的。在计算偏移量时，将其再作为整体。
>
> #pragma pack()的使用：
>
> ```cpp
> #pragma pack(push) //将当前pack设置压栈保存
> #pragam pack(2)  //在结构体定义之前使用
> struct { }；
>  #pragam pack(pop) //恢复之前的pack设置   具体字节对齐大小  由实际最宽和pack(n)取最小值
> ```
>
> 

#### reinterpret_cast

- 用于位的简单重新解释。

- 滥用容易带来风险。尽量考虑其他强制转换运算符，触雷转换本身是低级别的。

- 允许将任何指针转换为任何其他指针类型。

- 允许将任何整数类型转换为任何指针类型以及反向转换。

- 不能丢掉const、volatile或_unaligned特性。

- 一个实际用途是在哈希函数中。让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

  > 哈希函数对字符串进行计算，如果遇到整形数组等，可以reinterpret_cast<const char*>(hashes),转化为字符串。

#### bad_cast

由于强制类型转换为引用类型失败，dynamic_cast运算符引发bad_cast异常。

#### 运行时类型信息

dynamic_cast用于多态类型转换。

typeid

- typeid运算都允许在运行时确定类型对象。
- type_id返回一个type_info对象的引用。
- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数。
- 只能获取对象的实际类型。

type_info

- type_info类描述编译器在程序中生成的类型信息。此类的对象可以有效存储只想类型的名称的指针。type_info还适合存储比较两个类型是否相等或比较其排列顺序的编码值。类型的编码规则和排列顺序是未指定的，并且有可能因程序而异。

## 指针

### [智能指针](https://mp.weixin.qq.com/s/b_xlJF1-Cplgs-uawWuUow)

通用规则："->"表示指针原有的方法，"."表示智能指针本身的方法。

#### shared_ptr

原理：采用引用计数的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，引用计数+1，每减少一个智能指针指向智能对象时，引用计数会减1，计数为0时会自动释放动态分配的资源。

- 对一个对象进行赋值时，赋值操作符减少左操作数所指向对象的引用计数，并增加右操作数所指向对象的引用计数。

  ```cpp
  shared_ptr<int> p1 = new int(1024);//错误：必须使用直接初始化形式
  shared_ptr<int> p2(new int(1024));//正确：使用了直接初始化形式
  ```

拥有的方法：use_count() 返回引用计数大小

#### weak_ptr

弱引用，为了配合shared_ptr而存在。shared_ptr的引用计数存在的问题是[环形引用](https://blog.csdn.net/zhwenx3/article/details/82789537?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&utm_relevant_index=7)(例：A类中shared_ptr指向B，B中的指向A。两个类都等待被指向计数为0时进行销毁)，使用weak_ptr解决。weak_ptr只引用，不计数。所以指向内存不一定有效，使用前使用lock()检查是否为空指针。

本身拥有的方法主要包括：

- expired() 判断所指向的原生指针是否被释放，如果被释放返回true，否则返回false。
- use_count() 返回原生指针引用计数。
- lock() 返回shared_ptr,如果原生指针没有被释放返回一个非空的shared_ptr,否则返回一个空的shared_ptr。

#### unique_ptr

独享所有权，不支持不普通拷贝和赋值操作，不能用在STL标准容器中。(局部变量的返回值除外)

只能通过移动语义转移所有权。(std::unique_ptr\<A> a3 = std::move(a1));

拥有的方法：

- get()获取其保存的原生指针，不建议使用。

- bool()判断是否拥有指针。

- release()释放所管理指针的所有权，返回原生指针，但是不销毁原生指针。 

  ```cpp
  std::unique_ptr<A> a2(a1.release());  //转移拥有权
  ```

- reset()释放并销毁原生指针。如果一个参数为新指针，将管理这个指针。

  ```cpp
  a2.reset(new A); //释放原有对象，拥有一个新对象。
  a2.reset();   //释放并销毁原有对象，  等同下面写法。
  a2 = nullptr;
  std::unique_ptr<A> a_ = std::unique_ptr<A>(new A());  //创建方法
  
  std::shared_ptr<A> this_shared_ptr2 = shared_from_this() ; //共享当前对象指针
  std::unique_ptr<D> d2(new D(this_shared_ptr2));
  ```

#### 使用场景

由于性能，尽量使用unique_ptr,除非需要进行复制的场景。(例如：在同一个类中用unique_ptr,不同类中使用用shared_ptr)

```cpp
std::shared_ptr<A> a = std::make_shared<A>();  //make_shared只申请一个内存效率较高
std::shared_ptr<A> a1(new A());  //shared_ptr会申请两块内存
std::shared_ptr<A> a2 = a1;//编译正常，允许所有权的共享  使用方法
```

解决多线程下对象析构的问题:

> 背景：多线程下，设置了线程分离，存在对象已经析构，但是线程还在访问对象的情况造成内存泄露。

而使用只能指针，用shared_ptr管理对象，将weak_ptr传给子线程，子线程判断对象是否被销毁，如果没有被销毁，会通过weak_ptr换取shared_ptr，否则线程退出。解决了外部对象销毁，内部线程使用外部对象的野指针问题。  只要shared_ptr持有对象，就不会销毁对象，避免了多线程使用对象时被析构的现象。

#### 注意事项

- 使用智能指针托管的对象，不要再使用原生指针（例如手动释放原生指针，造成而此释放）。
- 不要把一个原生指针交给多个智能指针管理(会造成多次销毁)。
- 尽量不要使用get()获取原生指针。
- 不要将this指针直接托管智能指针。
- 智能指针只能管理堆对象，不能管理栈上的对象。

#### auto_ptr(C++11中已经弃用，使用unique_ptr进行代替)

auto_ptr不支持拷贝和复制操作，不能用在STL标准容器中。因为STL容器中的元素经常支持拷贝、复制操作，在这过程中auto_ptrh会传递所有权，auto_ptr不能指向数组，因为默认调用的时delete(而不是delelte[])。

#### make_shared

make_shared:模板函数 std::make_shared 可以返回一个指定类型的 std::shared_ptr。

shared_ptr 需要维护引用计数的信息：强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁(也可能释放)。

弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话)。

如果你通过使用原始的 new 表达式分配对象, 然后传递给 shared_ptr (也就是使用 shared_ptr 的构造函数) 的话, shared_ptr 的实现没有办法选择, 而只能单独的分配控制块:需要一块内存分配给Widget，还要一块内存分配给控制块。

如果使用std::make_shared来替换，一次分配就足够了。这是因为std::make_shared申请一个单独的内存块来同时存放Widget对象和控制块。

> 尽量使用make_shared初始化， 优点；

- 提高性能：只用分配一次 一块内存同时存放widget对象和控制块
- 异常安全：shared_ptr 和 new 是两步，中间可能被其他异常打算，new出来的内存，没有加入计数，被shared_ptr管理，自然得不到释放。而make_shared是一步完成，不存在这样的危险。

缺点：

构造函数是private或者protect时，无法使用make_shared。

注意事项：

原本强引用计数减为0就可以释放内存，而现在因为强引用、弱引用计数保存在一起，必须强、弱引用计数都减为0时，才能释放，延迟了内存的释放时间。

### 指针与引用

> 定义：
>
> 指针是一个变量，存储的是一个地址，指向内存。
>
> 引用是原变量的一个别名，跟原来的变量实质上是同一个东西。
>
> 引用的本质在C++内部实现是一个指针常量。

> 区别：

- 指针指向一块内存，指针的内容是所指向内存的地址，而引用是内存的别名。
- 指针可以在定义的时候不进行初始化，而引用必须要进行初始化。
- 指针可以在初始化之后进行修改，而引用不可以。
- sizeof运算结果，指针是 指针类型的大小 而引用是引用对象的大小。
- ++引用和++指针效果不一样，引用直接改变的是对应的对象，而指针改变的是指针的指向。
- 引用效率更高，因为在使用前不需要进行测试是否为空。
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能内存泄漏。
- 指针作为参数传递，本质上是值传递，传递的是地址值。

> 应用场景：

引用主要作为函数参数和返回值时使用。 重载操作符中使用引用，避免不必要的开销，提高效率。

并非指针不安全，而是程序员不安全。 代码水平不够会造成 野指针 内存泄漏等

> 引用是指针削弱版为什么还要用引用？

引用出现的地方都可以使用指针代替，但是在不需要改变指向对象，不需要指向为空或者多级指向的时候，尽量使用引用，因为他看起来更美观，效率更高(避免了创建存放形参指针的地址和地址指向的拷贝)。
主要原因是：支持操作符重载。 作为下标运算符时使用。可以专注于数据对象本身，而不是抽象的指针表示。

1. ==仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）==

两个地址相减，结果并非是直接运算结果，而是除以指针指向类型的的大小。表示两个指向的两个内存相差了个几个指针类型的大小。

```cpp
int a = 10000;
int b = 20;

int *p1 = &a;
int *p2 = &b;

int num = p1 - p2;

printf("p1= %x\n", p1);
printf("p2= %x\n", p2);
printf("num的地址=%x, num=%d\n", &num, num); 
//输出  int 4个字节 栈地址由高向低分配
//p1= 61fddc
//p2= 61fdd8
//num的地址=61fdd4, num=1
```

### 指针安全

野指针：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的），进行解引用的后果也是不可预料的。

导致原因：

- 指针创建时未初始化。
- 指针释放时未置空。
- 访问越界。

避免办法：

- 初始化置nullptr
- 申请内存 判断
- 指针释放后置nullptr
- 使用智能指针
- 使用RAII 资源获取即初始化， 构造函数获取资源，析构函数释放

#### 内存泄漏

概念：指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

程序异常，没有执行到释放指针就被中止，也会引起内存泄漏，可以使用智能指针，进行释放。

解决：

- 代码层面

  - 内存申请和释放要成对使用
  - 使用智能指针

- 工具检测

  - vs2017 main函数开始和结尾分别[拍摄快照](http://t.csdn.cn/eKZYi)，查看堆分析，定位跳转到未释放的申请处。

  - linux下使用**valgrind**。

    命令：valgrind --tool=mecheck ./a.out
  
    进一步获取详细内存泄漏信息：valgrind --tool=mecheck --leek-check=full ./a.out
  

### 数组与指针

```cpp
double wages[] = {100.0, 200.0, 300.0};
duoble *pw = wages;  //等价于  doule *pw = &wages[0]  指向数组中第一个元素的地址。
//使用数组时 C++执行如下转换：wage[i]   becomes *(wage + i)
```

获取数组元素使用指针  解除引用运算符和数组名下标访问区别

1. 可以修改指针的值，而数组名是常量。 ptr++  vaild   		wage+=1   not allowed  
2. sizeof(ptr) 是指针长度。 sizeof(wages) 是数组长度。

数组地址：

&wages[0]\(即wages) 和 &tell  两者打印地址相同，但是概念上前者是一个2字节地址，+1 增加2，后者是一个24字节地址，&tell + 1将地址增加24。

## C++ 内存

### 内存布局 

- 代码区：存放函数题的二进制代码，由操作系统进行管理的。
- 全局区：存放全局变量和静态变量以及常量。
- 栈区：由编译器自动分配和释放，存放函数的参数值，局部变量等。
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统进行回收。
- 自由存储区：new操作符申请资源存放的地方，是C++抽象概念，一般是在物理上申请在堆上，具体实现可以申请在其他地方。

对于栈的区别：

- 栈式编译器控制的，而堆上资源的创建和释放由程序员控制。
- 空间大小不同，堆的空间(32位，可达3G)比较大，而栈空间较小。
- 对于堆来讲，频繁的内存分配和释放势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对栈来讲，内存都是连续，不会造成大量碎片。
- 地址增长方式不同，堆由低到高，栈由高到低。
- 分配方式不同：堆都是动态分配的。而栈有动态分配、静态分配两种。静态分配是编译器完成的，比如局部变量的分配，而栈的动态内存分配则是通过alloca()函数分配。
- 分配效率不同：栈有专门的操作系统分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，决定了栈的效率比较高。堆由对应的库函数完成，设计复杂的逻辑，分配和释放效率较低。

意义：赋予不同的生命周期，给以更大的灵活编程。

![image-20220507153031140](资料整理.assets/image-20220507153031140-16519086331611.png)



text段在内存中被映射为只读；

  variable:优化器在用到这个变量时必须每次都小心地重新读 取这个变量的值； 

  **data**包含静态初始化的数据，所以有初值的全局变量和static变量在data区’ 

  **bss**是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。.bss段在编译出的目标文件中是不占空间的。在装载时进行开辟空间。

对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。

**程序运行前**

- C++在程序运行前分为全局区和代码区。
- 特点是只读和共享。
- 全局区中存放全局变量、静态变量、常量。
- 常量区中存放const修饰的全局常量和字符串常量("abc")。

### [内存池](https://cloud.tencent.com/developer/article/1177145)

定义：内存池(Memory Pool)是一种内存分配方式，在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是，使得内存分配效率得到提升。通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。 

实现：

- 类模板
- 链表保存每一块可用内存，分配出一个，删除对应节点。

### **程序启动的过程：**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。

### **字节对齐：**

**原因**：不对齐的话需要读取多次，拼凑出目标数据。对齐后可以一次读取，提高效率，不对齐的话在某些系统是会发生错误的。

**对齐规则**：数据类型自身的对齐值：char 1 		short 2		int float 4		double 8

​					数组以数组类型为准：如int [] 对齐值为4
​					指定对齐值：#pragma pack (value)时的指定对齐值value。
​					对于结构体嵌套地情况：深度优先填充。

- 联合：按照包含的长度最大的数据类型对齐。

  {int a; double b; float c;}  大小为24字节。

  不能用函数**memcpy**来判断两个结构体是否相等：memcpy函数是逐个字节进行比较的，而struct存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。

  与strcpy相比，memcpy并不是遇到'\0'就结束，而是一定会拷贝完n个字节。

### 常见内存错误及对策

- 内存未分配成功，却使用了

- 分配了，未初始化

- 访问越界

- 忘记释放，造成内存泄漏

- 释放了却继续使用(野指针)。


避免：

- 避免在堆上分配。
- 申请释放成对使用，malloc free new delete new[] delete[]
- 避免使用裸指针
- 尽量使用STL(例如string代替 char*)或自己实现对象。
- RALL(资源获取即初始化)，使用对象实现，通过构造创建，析构自动释放的原理。

#### 内存泄漏定位方法：

- 日志：每次分配和释放内存的时候，都打印内存的地址。分配条数大于释放的条数，存在泄漏，查看日志再详细定位。

- 统计：创建三个对象分别：分配内存并计数，释放内存并计数，检查内存泄漏。

- 实用工具Linux上的valgrind。命令：valgrind --leak-check=full ./leak。 

  windows下 UMDH工具

### [内存模型与c++中的memory order](https://www.cnblogs.com/ishen/p/13200838.html) 

- c++的atomic使用总会配合各种各样的memory order进行使用，memory order控制了执行结果在多核中的可见顺序，，这个可见顺序与代码序不一定一致(第一句代码执行完成的结果不一定比第二句早提交到内存)，`其一是进行汇编的进行了指令优化重排，其二是cpu实际执行时乱序执行以及部分cpu架构上没有做到内存强一致性`(内存强一致性：可以简单的理解为，执行结果出现的顺序应该和指令顺序一样，不存在重排乱序),导致后面的代码执行完成的时候，前面的代码修改的内存却还没改变

- `结果序和代码序不一致不一定会导致问题，但在可能出现问题的场景下，就需要手动干预以避免问题`，汇编(软件)和cpu(硬件)都提供了相应的指令取进行干预控制，c++的atomic中的memory order可以看成是这些控制的封装，隐藏了底层，之所以有六种是因为这种控制是有代价，从松散到严格开销越来越高，在某些场景下，我们是允许部分重排的，只是对于小部分重排会导致问题的才需要加以控制，那么只需要衉一些低开销的控制即可。

- 硬件内存模型：由于CPU计算能力远超过了从DRAM(主存)中读写得速度，所以引入了cache，store buffer，invalidate queue等硬件提升数据读写速度，并增加了乱序执行，(如一个单元读取，一个单元计算)提高使用率。

- 存储模型

  - 顺序一致性模型(**sequential consistency model**)：多线程程序的运行所期望的执行情况是一致的，不会出现内存访问乱序的情况；
  - 完全存储顺序(**total store order**):为了提高CPU的性能，芯片设计人员在CPU中包含了一个存储缓存区（store buffer），它的作用是为store指令提供缓冲，使得CPU不用等待存储器的响应。所以对于写而言，只要store buffer里还有空间，写就只需要1个时钟周期,但这也引入了一个访问乱序的问题。`store flag = set; load r1 = data`顺序存储模型中，存储指令肯定优先执行完毕，但是完全存储模型中，将store指令放到store buffer后会立即返回，然后执行load命令，可能load先执行完毕，尤其data在cache 而 flag不在得情况下。定义store buffer必须严格按照FIFO的次序将数据发送到主存。常用的物理机上的x86 CPU 就是这种内存模型
  - 部分存储顺序(**part store order**)：为了进一步提升性能，在TSO基础上进一步放宽内存访问限制。允许非FIFO来处理缓冲区命令，只有对相同地址做store才有严格顺序执行。允许store-load，store-store乱序
  - 宽松存储模型(**relax memory order**)：为了榨取性能，在PSO基础上继续放宽内存一致性模型，只是地址无关指令(同一个内存地址读写)，在读写访问时可以打乱所有load/store得顺序。允许store-load，store-store，load-load，load-store乱序

  ![image-20221005101438503](C:\Users\Wei FC\AppData\Roaming\Typora\typora-user-images\image-20221005101438503.png)

storebuffer帮助core在进行store操作的时候尽快返回，这里的buffer和cache都是硬件，空间较小，满了之后要将buffer中得数据刷到cache，刷到得数据更新就会同步，告知其他cache持有数据失效，进行同步，由于其他core可能在忙不一定能及时处理invalidate。因此又引入了invalidate queue用来存放发送过来得message。但是可能造成持有旧数据，使用smp_mb()  刷新。





#### 请简述一下atomoic内存顺序。

**参考回答**

有六个内存顺序选项可应用于对原子类型的操作：

memory_order_relaxed：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性。

memory_order_consume：memory_order_consume不会造成acquire带来的误伤，只要求依赖于本本语句读得不能乱序。

memory_order_acquire：使用memory_order_acquire的原子操作，读操作不能在此之前。

memory_order_release：使用memory_order_release的原子操作，写语句操作不能放在本语句之后。

memory_order_acq_rel：memory_order_acq_rel在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后。

memory_order_seq_cst：memory_order_seq_cst比std::memory_order_acq_rel更为严格。memory_order_seq_cst不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。

- **memory_order_seq_cst：**顺序一致性模型。这个选项语义上就是要求底层提供顺序一致性模型，这个是默认提供的最强的一致性模型，在这种模型下不存在任何重排，可以解决一切问题。

  在底层实现上：程序的运行底层架构如果是非内存强一致模型，会使用cpu提供的内存屏障等操作保证强一致，在软件上，并要求代码进行编译的时候不能够做任何指令重排，

- **memory_order_release/acquire/consume:**(完全存储 部分存储)
  提供release、acquire或者consume, release语意的一致性保障
  它的语义是：我们允许cpu或者编译器做一定的指令乱序重排，但是由于tso, pso的存在，可能产生的store-load乱序store-store乱序导致问题，那么涉及到多核交互的时候，就需要手动使用release, acquire去避免这样的这个问题了，与memory_order_seq_cst最大的不同的是，其是对具体代码可能出现的乱序做具体解决而不是要求全部都不能重排

- **memory_order_relaxed:** 提供松散一致性模型保障，不提供operation order保证。
  这种内存序使用在，完全放开，让编译器和cpu自由搞，如果cpu是SC的话，cpu层不会出现乱序，但是编译层做重排，结果也是无法保证的，很容易出问题，但可用在代码上没有乱序要求的场景或者没有多核交互的情况下，提升性能。

除非你为特定的操作指定一个顺序选项，否则内存顺序选项对于所有原子类型默认都是memory_order_seq_cst。

## STL

### 组成

- 容器：一种数据结构，以模板类的方法提供。
- 算法：用来操作容器中数据的模板函数，如sort、find等，函数本身和他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
- 迭代器：提供了访问容器中对象的方法。迭代器如同一个指针。
  - 指针与迭代器：指针属于迭代器的一种。迭代器比指针有更细的划分并且功能不同。迭代器表现得像指针，模拟了指针得一些功能，通过重装> ++ - -等封装了指针，提供了比指针更高级的能力。
  - 迭代器返回的是对象的引用而不是对象的值，所以cout只能输出取值后的值而不能输出自身。
- 适配器：接口类，专门用来修改现有类的接口，提供一种新的接口，或者调用现有的函数来实现所需要的功能，主要包括container Adaptor、Iterator Adaptor、Function Adaptor。
- 仿函数：又称函数对象，重载了操作符struct
- 空间配置器：主要包括两部分工作：对象的创建与销毁、内存的获取与释放。

### STL容器

|     容器      |  底层数据结构   |                 时间复杂度                 | 是否有序 | 是否可重 复 |                             其他                             |
| :-----------: | :-------------: | :----------------------------------------: | :------: | :---------: | :----------------------------------------------------------: |
|     array     |      数组       |                随机读改O(1)                |   无序   |   可重复    |                         支持随机访问                         |
|    vector     |      数组       | 随机读改、尾部插入(删除)O(1)、头部插入O(n) |   无序   |   可重复    |                         支持随机访问                         |
|     deque     |    双端队列     |          头部/尾部插入、删除O(1)           |   无序   |   可重复    | 一个中央控制器+多个缓冲区，支持首位快速增删，支持==随机访问==。 |
| forward_list  |    单向链表     |               插入、删除O(1)               |   无序   |   可重复    |                       不支持随机访问。                       |
|     list      |    双向链表     |               插入、删除O(1)               |   无序   |   可重复    |                       不支持随机访问。                       |
|     stack     |   deque/list    |           顶部插入、顶部删除O(1)           |   无序   |   可重复    | deque或list封闭头端开口，不用vector的原因应该是容量大小有限制。扩容耗时 |
|     queue     |   deque/list    |           尾部插入、头部删除O(1)           |   无序   |   可重复    | deque或list封闭头端开口，不用vector的原因应该是容量大小有限制。扩容耗时 |
| priorty_queue | vector+max-heap |            插入、删除O(log~2~n)            |   有序   |   可重复    |                   vector容器+heap处理规则                    |
|      set      |     红黑树      |         插入、删除、查找O(log~2~n)         |   有序   |  不可重复   |                                                              |
|   multiset    |     红黑树      |         插入、删除、查找O(log~2~n)         |   有序   |  不可重复   |                                                              |
|      map      |     红黑树      |         插入、删除、查找O(log~2~n)         |   有序   |  不可重复   |                                                              |
|   multimap    |     红黑树      |         插入、删除、查找O(log~2~n)         |   有序   |  不可重复   |                                                              |
| unordered_set |     哈希表      |        插入、删除、查找O(1)最差O(n)        |   无序   |  不可重复   |                  unordered_mutliset(可重复)                  |
| unordered_map |     哈希表      |        插入、删除、查找O(1)最差O(n)        |   无序   |  不可重复   |                 unordere_multimap(不可重复)                  |

### STL容器分类

#### 顺序容器：容器并非排序的，元素位置与与插入顺序有关，与值无关。

**1.vector 连续存储结构**（逻辑物理均连续）
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此能高效的进行随机存取，时间复杂度为o(1)，高效的尾端插入删除操作;
但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

只有连续存储的容器才有capacity的概念（vector、deque、string)

**2.deque双向开口的连续线性空间**(逻辑连续，物理非连续)

deque是在功能上合并了vector和list。(只有既要随机访问，又需要在首端进行插入/删除时使用deque,否则使用vector)

与 [std::vector](https://zh.cppreference.com/w/cpp/container/vector) 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。

 优点：(1) 随机访问方便，即支持[ ]操作符和vector.at()
        (2) 在内部方便的进行插入和删除操作
        (3) 可在两端进行push、pop
   缺点：占用内存多
  使用区别：
   （1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
   （2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list
   （3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque

**3.list数据结构**(均不连续)
list是由双向链表实现的，因此内存空间是不连续的。
只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
但由于链表的特点，能高效地进行插入和删除。

链表：将数据元素作为一个节点，用指针将节点连接起来的一种非顺序存储结构但逻辑顺序连续的线性表。

#### 关联式容器

关联式容器：元素是排序的，元素位置与值有关，查找时有较好的性能，通常以平衡二叉树实现。包含set、multiset、map、multimap。

#### 容器适配器

封装了一些基本容器，使之具备新的函数功能，比如把deque封装一下成为一个具有stack功能的数据结构，新的得到的数据结构就叫适配器。包含stack、queue、priority_quequ。

### STL空间配置器实现

将对象构造分为：空间配置和对象构造两部分。

内存配置操作通过alloc::allocate()实现。   内存释放操作：通过alloc::deallocate()。

对象构造操作通过construct()实现， 对象释放操作通过destory()实现。

关于内存空间的配置与释放，采用了两级配置器，一级配置器考虑大内存空间，利用malloc和free实现，二级配置器主要考虑小内存空间而设计的(为了最大化解决内存碎片问题，进而提升效率)，采用链表free_list来维护内存池(memory pool)，free_list通过union结构实现，空闲的内存互相挂接在一块，一旦被使用就从链表中剔除。

一级空间配置器：直接使用malloc是因为不用调用构造函数。

二级空间配置器：使用内存池技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式来提供用户获取空间的速度和高效管理。通过哈希桶来解决 明确归还空间在内存池位置的问题，即还到哪里。

### STL函数函数解析

#### resize和reserve的区别

resize既分配了空间，也创建了对象。reserve表示容器预留空间，但是并不真正的创建对象，需要通过insert或push_back()等创建对象。

resize修改size大小，reserve修改capacity大小。





#### STL算法

| 算法 | 底层算法              | 时间复杂度   | 可不可重复 |
| ---- | --------------------- | ------------ | ---------- |
| find | 顺序查找              | O(n)         | 可重复     |
| sort | [内省排序](#内省排序) | O(n*log~2~n) | 可重复     |

### 优先队列 priority_queue

> #### 定义

priority_queue<Type, Container, Compare>  头文件  #include\<queue>

例：priority_queue<int, vector\<int>,  greater\<int>> pr; 

Type是要存放的文件类型；Container是实现底层堆的容器，必须是数组实现的容器，如vector、deque；Compare是比较方式； priority_queue\<Type> 此时默认容器时vector,比较方式是大顶堆less\<Type>

Compare,基本数据类型可以使用less\<Type>表示大顶堆，greater\<type>表示小顶堆。

#### 常用函数

top(), pop(), push(), emplace(), empty(), size()。

#### 自定义比较方式

当数据类型不是基本数据类型时，而是自定义数据，就需要自定义比较方式。

假如自定义数据类型时名为fruit的对象:

```cpp
struct fruit{
	string name；
    int price;
};
```

有两种实现的方式：

##### 重载运算符

若希望水果价格高的在堆顶，则重载"<"(价格低的在堆顶，则重载">"，下方"<"替换为">")。

```cpp
struct fruit{
	string name;
    int price;
    firend bool compare<(fruit& f1, fruit& f2){
		return f1.price < f2.price;
    }
};
```

##### 仿函数

若希望水果价格高的在堆顶，则：(价格低的实现方式同理)

```cpp
//大顶堆
strcut myComparison{
	bool operator()(furit& f1, fruit& f2){
		return f1.price < f2.price;
    }
}；
```

### STL容器的一些新成员函数

#### emplace_back emplace 等

比push_back()   更高效，push_back()一个新对象，会调用 构造 拷贝构造 析构各一次

而emplace只会调用构造函数一次。

#### try_emplace  C++17

如果不存在插入元素，存在则什么也不做。

​	

### map与Hashmap

#### hash_map   \#include "stlport\hash_map"

原理：使用一个下标范围较大的数组来存储元素。可以设计一个函数(哈希函数或叫做散列函数)，使得每个元素的关键字都与一个函数值(即数组下标)相对应。

直接定址和解决冲突时哈希表两大特点。

hash_map<key, value, hash<>, equal_to<>>;  

原理：首先分配一大片内存，形成许多桶，通过hash函数，将key映射到不同的桶仅从保存。

> 声明自己的的哈希函数需要注意：

- 使用struct，然后重载operator()。

- 返回值是是size_t。

- 参数是要hash的key的类型

- 函数是const类型

  ```cpp
  //哈希函数
  struct str_hash{
      size_t operator()(const string& str) const{
          unsigned long _h = 0;
          for(size_t i =0; i < str.size(); ++i )
              _h = 5 * _h + str[i];
          return size_t(_h);
      }
  };
  //自定义比较函数
  //key为类时，在类中重载==
  struct mystruct{
          int iID;
          int  len;
          bool operator==(const mystruct & my) const{
                  return (iID==my.iID) && (len==my.len) ;
          }
  };
  //自定义仿函数
  struct compare_str{
          bool operator()(const char* p1, const char*p2) const{
                  return strcmp(p1,p2)==0;
          }
  };
  ```

hash_map取值过程: 1.获得key。 2.对key进行hash。 3.得到桶号(hash值对桶数取模)。 4.比较桶的内部元素是否与key相等，若都不想等，则没有找到。 5. 找出key相等的记录的value。

取模运算  X % 2^n = X & (2^n – 1)   与效率不高

可以看到查找过程需要判断key是否相等，自定义数据类型需要重载==，实现比较函数。有了比较函数，就可以实现hash_map了。

> hash_map和map的区别？

构造函数。hash_map需要hash函数，等于函数。map只需要实现比较函数(小于函数)。

存储结构。hash_map采用hash表存储，map一般采用红黑树实现。(unordered_map也是哈希表)。

应用场景：hash_map查找效率是O(1),map是O(log(n))。在数据量较大时，想要较好的查找效率，使用hash_map。如果想要内存消耗相对较少，使用map。而且hash_map构造较慢。

##### [哈希函数构造方法](http://t.csdn.cn/94H4N)

- 直接定址法
- 除留余数法
- 数字分析法：取出数字种某几位 分布较为均匀 比如都去最后两位 基本不重复
- 折叠法：数位分割成位数相同的几部分，然后相加。
- 平方取中法：先计算出关键字的平方，然后根据可使用空间大小，选取中间几位为哈希地址。  常用

##### 哈希冲突

定义：两个不同的数经过哈希函数计算后得到了同一个结果，即会被映射到哈希表的同一个位置。

解决办法：

1. 开放定址法：寻找一个新的空闲的哈希地址

   - 线性探测(不断加+1并取模，直到找到空闲地址)	 	问题：堆积或聚集现象(多个不同的哈希值抢占同一个后续的哈希地址)

     h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）

   - 平方探测法(二次探测法)

     h(x)=(Hash(x) +i)mod (Hashtable.length);（i依次为+(i^2^) 和 -(i^2^)）
     
   - 随机探测

2. 再哈希法：同时构造多个不统哈希函数，当地一个哈希函数冲突后，使用第二哈希函数计算，直到不发生冲突。

3. 链地址法：所有哈希地址相同的记录都链接到同一个链表中。

4. 建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的哈希都存放在溢出表中。

## 对象

### 类的默认成员函数 编译器自动生成

构造函数

拷贝构造函数

析构函数

赋值运算符重载函数(让两个对象之间进行赋值)

取地址重载

const取地址重载

### 构造函数

分类：

- 默认构造函数
- 初始化构造函数
- 复制构造(拷贝构造)
- 移动构造函数    临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。  move
- 转换构造函数

左值：可以&取地址的，剩下的都为右值，匿名变量都是右值。

左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。

常量左值引用可以接收左值、右值、常量左值、常量右值，而左值引用只能接收左值。

移动构造函数：

```cpp
//移动构造函数，与参数为左值引用的深拷贝构造函数基本一样
Integer(Integer&& source)
  : ptr_(source.ptr_) {
    source.ptr_ = nullptr;
    cout << "Call Integer(Integer&& source)" << endl;
}

    Integer a(Integer(100));  //这里对右值(匿名变量)实现了移动构造
    int a_value = a.GetValue();
    cout << a_value << endl;   
//输出
//Call Integer(int value)
//Call Integer(Integer&& source)
//Call ~Integer()
//100
std::move()  可以把左值强制转换为右值。  Interger temp;  Interger b(std::move(temp));  就可以调用以上移动构造函数了。 
```



#### 为什么构造函数不能为虚函数？

1. 从存储空间角度

   虚函数对应一个vtable存储在对象内部，如果构造函数是虚函数，就需要通过vtable来进行构造，而此时对象还没有实例化，还没有存储空间，自然不存在vtable。所以不可以为虚函数。

2. 使用角度

   虚函数作用是通过父类的指针或者引用来调用它的时候能够编程子类的那个成员函数，而构造函数是在初始化时自动调用的，不可能通过父类的指针或者引用去调用。

3. 实现上看

   vtable是在构造函数调用创建对象实例时才建立的，因而构造函数不可能时虚函数。

4. 从实际意义上看

   构造函数在调用时还不能确定对象的真实类型(因为子类会调用父类的构造函数)。而且构造函数提供初始化，在对象生命周期内只执行一次，不是对象的动态行为，也没有必要成为虚函数。

#### C++中必须在类初始化列表中初始化的几种情况：

- const类型的成员变量  const对象或者引用只能初始化不能赋值。  从无到有是初始化，赋值操作是没有创建对象，而是对已有对象赋值。
- 引用类型的成员变量
- 带有引用的类的成员变量
- 如果类中存在继承关系，派生类必须在初始化列表中调用基类的构造函数。

### C++ 类对象的初始化顺序，有多重继承情况下的顺序

- 创建派生对象，基类的构造函数优先被调用(也优先于派生类的成员类)。
- 如果类里有成员类，成员类的构造函数优先被调用。(也优于该类本身的构造函数)
- 继承基类，构造函数调用顺序是初始化列表的顺序。
- 成员类对象构造函数如果有多个成员类对象，调用顺序是在类中被声明的顺序。
- 派生类构造函数，一般不能直接向一个基类数据成员赋值，而是将值传递给适当的基类构造函数，否则变成紧耦合的。

### C++对象模型和this指针

#### sizeof对象

在C++类中，类内的成员变量和成员函数分开存储。

只有非静态成员变量才属于类的对象上。

sizeof时，只计算虚表(如果有的话)可以非静态成员变量。

所有对象共享同一个函数实例。

#### this指针用途

- 形参和成员变量同名时，可用this指针来区分。

- 在类的非静态成员函数中返回对象本身，可使用return *this。

- 空指针访问函数成员：

  ```cpp
  Preson *p = nullptr;
  p->show(); //空指针 可以调用成员函数，但是如果函数中用到了this指针就不可以了。
  ```

#### 常函数，常对象

- 常函数内不可修改成员属性。
- 成员属性声明时加上mutable，在常函数中依然可以修改。
- 常对象只能调用常函数。

#### 友元

实现方式：

- 全局函数做友元。
- 类做友元。
- 成员函数做友元。

#### 运算符重载

非成员函数需要两个参数， 成员函数需要一个参数，因为this指针已经隐式包含了另一个参数。

不使用引用的话，不能实现形式上和基本数据类运算一致，在传递的时候需要传递指针 而不是变量本身，接收也必是是指针。

##### 加号运算符重载：

```cpp
//友元函数实现+运算符重载
class Person{
  Preson operator+(const Person* p){
      Person temp;
      temp.m_A = this->m_A + p.m_A;
      return temp;
  }  
};
//全局函数实现+运算符重载
Person operator+(const Persopn& p1, const Person& p2){
	Person temp();
    temp.m_A = p1.m_A + p2.m_A;
    return temp;
}
//运算符可以发生函数重载
Person operator+(const Person& p1, int val){
    Person temp;
    temp.m_A = p1.m_A + val;
    return temp;
}
```

##### 左移运算符重载

作用：可以输出自定义的数据类型。

```cpp
class Person{
  friend ostream& operator<<(ostream& out, Person& p);  
}; //成员函数无法实现
//全局函数实现左移重载
//ostream对象只能有一个
ostream& opearotr<<(ostream& out, Person& p){ //输入  istream
    out << "a:" << p.m_A;
    return out; //返回输出对应引用，可以实现链式编程 如下
}
cout << p1 <<  p2 << "hello" << endl;  //链式编程

```

##### 递增运算符

```cpp
class MyInteger{
	MyInteger& operator++() {  //前置++
		m_Num++;
        return *this;
    }
    MyInteger operator++(int)const {  //后置++  //const 是禁止 i++++; 原因：1.内置类型行为不一致。 2.i只会加1,第二个修改的是临时对象，这令人迷惑。
		MyInteger temp = *this;
        m_Num++;
        return temp;
    }
};
++i; // 调用 i.operator++();
i++; // 调用 i.operator++(0);
```

##### 赋值运算符重载

编译器提供浅拷贝

```cpp
//重载运算符实现深拷贝
class Person{
    int  * m_Age;
    Person(int age){
        m_Age = new int(age);
    }
	Person& operator=(const Person& p){
        if(m_Age != nullptr){
			delete m_Age;
            m_Age = nullptr;
        }
        //m_Age = p.m_Age;  //编译器提供的这个 是浅拷贝
        m_Age = new int(*p.m_Age);
        return *this;
    }
}；
```

还有关系运算符重载，写法同上。

##### 函数调用运算符重载

- 由于重载后的使用方式非常像函数的调用，因此成为仿函数。
- 仿函数没有固定写法，非常灵活。

```cpp
class myAdd{
public：//以上重载也都需要加上public  否则在类外无法调用重载后的成员函数
	int operator()(int val1, int val2){
    	return val1 + val2;
	}       
}；
void test(){
    myAdd add;
    cout << add(10, 10) << endl;
    cout << myAdd()(100, 100) << endl; //匿名函数调用
} 
```

##### 不能被重载的运算符

- **.** 成员运算符。
- ***** 成员指针访问运算符。
- **::** 域运算符
- **sizeof**  长度运算符
- **? :** 条件运算算符 

前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。

### 继承

- 子类和父类出现同名的成员，子类如何访问父类中的同名数据？子类可以直接访问子类成员，访问父类成员加上作用域。静态成员函数亦是如此处理。

### 多态

#### 定义、分类及区别

分类：

- 动态多态：派生类和虚函数运行实现时多态。
- 静态多态：函数重载和运算符重载属于静态多态。

区别

- 静态多态的函数地址早绑定——编译阶段确定函数地址。
- 动态多态的函数地址晚绑定——运行阶段确定函数地址。

总结：

- 多态满足的条件
  - 有继承关系
  - 子类重写父类中的虚函数

- 多态使用的条件
  - 父类指针或者引用指向子类对象

重写：函数返回值、类型名、参数列表完全一致成为重写。

- 函数重写的两个例外：
  - 协变：子类的虚函数和父类虚函数的返回值不同，也能构成重写。但需要的是子类的返回值是一个子类的指针或者引用，父类返回的是父类的指针或者引用。且返回值代表的两个类也具有继承关系。
  - 析构函数的重写：析构函数天生名字不一样，如何重写？析构函数被编译器替换为了Destructor，只要父类的析构函数用virtual修饰，子类是否有virtual都构成重写。

#### 多态运行原理  过程

编译器"看到"，满足多态的条件，就会根据指针找到对应对象的虚函数表。根据虚函数表找到虚函数地址，然后访问虚函数。

子类覆盖了父类的虚函数，子类可以通过加上作用域调用父类的虚函数。在编译时早绑定。

- 编译器会自动为每个包含虚函数的类生成一份虚函数表，一维数组，保存了虚函数的入口地址。
- 编译器会在每个对象一般是前四个字节保存一个虚表指针，指向对应虚表，并进行初始化，存放对应的虚函数。子类继承时，会替换虚表中已重写函数的地址。
- 父类指针指向子类对象时，根据虚表找到对应应该调用的函数。



#### 虚函数指针、虚函数表

类与虚表关系：一个类只有一个虚表。

对象与虚表关系：对象共享一个虚表。

虚函数表内存空间布局：

- RTTI 运行时类型信息
- 偏移
- 虚函数入口地址

虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。

虚函数表：在程序的只读数据段，存放虚函数指针，如果派生类实现了基类的某个函数，则在虚表中覆盖原本基类的那个虚表指针，在编译时根据类的声明创建。

虚函数表指针指向虚函数表，在类中只是一个指针，32位下占用空间4字节。同一个类的不同实例共用同一份虚函数表，都通过虚函数表指针__vfptr(void**类型)指向该虚函数表。

定义了基类没有的虚函数的单继承的类对象布局：**继承类`Derive1`的虚函数表被加在基类的后面**。

多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局：子类的虚函数表被加在第一个声明继承基类的后面。子类实现虚函数会覆盖虚函数表中的指向。

 **谁有虚函数表, 谁就放在前面**!

虚继承、虚函数

相同之处：

- 都利用了虚指针(均占用类的存储空间)和虚表(均不占用类的存储空间)

- 不同之处：

  - 虚继承 //将共同基类设置为虚基类，避免菱形继承，共用一份数据。
    - 虚基类依旧存在继承类中，只占用存储空间。
    - 虚基类表存储的是虚基类相对直接继承类的偏移。

  - 虚函数
    - 虚函数不占用存储空间
    - 虚函数表存储的是虚函数地址

#### 抽象类、接口类、集合类

抽象类：含有纯虚函数的类。

接口类：仅含有纯虚函数的抽象类。

聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下条件：

- 所有成员都是public。
- 没有定义任何构造函数。
- 没有类内初始化。
- 没有基类，也有没有virtual函数。

#### 函数重载

函数重载条件：

- 在同一个作用域下。
- 函数名称相同。
- 函数的<u>参数类型</u>或者<u>参数个数</u>或者<u>顺序不同</u>。

注意：

- 返回值不同不能作为函数重载的条件。因为在调用时无法确定。
- 引用作为重载条件，常量(字面值、字符串常量，const等)可以作为重载条件，如fun(10)，调用对应的常量fun(cosnt int& a)。
- 使用默认参数注意避免引起歧义。传入一个参数时，存在重载的两个默认参数的函数和一个参数的函数，无法确定调用哪个。

（1）如果使用某个类的成员函数来重载这些运算符，则意味着这些运算符仅针对该特定类才被重载。

（2）如果重载是在类外部完成的（即它不是类的成员函数），则只要您使用这些运算符（在类内或类外），都将调用重载的“ new”和“ delete”。这是全局超载。

重载、覆盖(重写)、重定义(隐藏)：

- 重载：在同一作用域，函数名相同，参数列表不同。
- 重写：虚函数，处于父类和子类中，返回值、参数列表、函数名必须相同(协变除外)。
- 重定义：子类和父类的成员变量相同或者函数名相同。子类隐藏父类对应的成员函数。
- ”但为什么不将函数返回类型考虑到函数重载中呢？——这是为了保持解析操作符或函数调用时，独立于上下文（不依赖于上下文），

#### 纯虚函数和抽象类

纯虚函数语法： virtual 返回值类型 函数名（参数列表）= 0；

当函数冲有了纯虚函数，这个类成为抽象类。

抽线类特点：

- 无法实例化对象。
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类。

#### 虚析构和纯虚析构

动机：多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类的析构代码。

解决方式：将父类的析构函数改为虚析构或者纯虚析构。

总结；

- 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象。
- 如果子类没有堆区数据，可以不写为虚析构或纯虚析构。
- 拥有析构函数的类也属于抽象类。

## 其他功能语法

### 模板

模板在没有被真正被使用前，编译器是无法知道所占空间大小。

套用不同类型，生成不同的代码。模板类的实现，脱离具体的使用，是无法单独编译的；把声明和实现分开也是不可以的，必须把声明和实现都写在头文件里面。

**函数模板与类模板的区别**

- 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式的指定。（即，函数模板允许隐式调用和显式调用，而类模板只能显示调用）
- 函数模板不可以有默认参数，而类模板允许有默认参数。

模板 泛型：泛型是概念, 模板是泛型的实现。  泛型：写出的代码和其所处理的对象类型彼此独立。

#### 模板类虚函数 模板成员虚函数

模板类可以有虚函数：C++要求类在实例化前就被内存布局，而模板类中的虚函数大小是确定固定的，虚表可以确定下来，就可以有虚函数。

模板成员虚函数：类中模板虚函数可以被多次调用，根据不同类型会有func(int), func(double), 实例化之处有不确定数量func(), 内存布局无法确定，就无法完成实例化。

```cpp
template <class T>
class A{
	template <class T2>
    void func(T2 a) {cout << a;}  //模板成员虚函数    fail
}
```

class

### 文件操作

文件操作需要包含头文件\<fstream>

文件类型：

- 文本文件：文件以文本的ASCII码形式存储在计算机中。
- 二进制文件：文件以文本的二进制形式存储在计算机中。

[C++文件读写详解（ofstream,ifstream,fstream）](http://t.csdn.cn/irJzQ)

操作文件类型

- ofstream：写操作

- ifstream：读操作

- fstream： 读写操作

  ![std-io-complete-inheritance.svg](https://upload.cppreference.com/mwiki/images/0/06/std-io-complete-inheritance.svg)

  ![img](http://www.cplusplus.com/img/iostream.gif)

#### 文本文件

##### 写文件

写文件步骤：

- 包含头文件 #include\<iostream>

- 创建流对象 ofstream ofs;

- 打开文件 ofs.open("文件路径"， 打开方式)；

- 写数据 ofs << "写入的数据"

- 关闭文件 ofs.close();

  文件打开方式

  |  打开方式   |            解释            |
  | :---------: | :------------------------: |
  |   ios::in   |        只读打开文件        |
  |  ios::out   |        只写打开文件        |
  |  ios::ate   |      初始位置：文件尾      |
  |  ios::app   |       追加方式写文件       |
  | ios::trunc  | 如果文件存在，先删除再创建 |
  | ios::binary |       二进制方式打开       |

  注意：文件打开方式可以配合使用，利用 | 操作符。

  例如：用二进制方式写文件 ios::binary | ios::out

##### 读文件

读文件操作流程类似于写文件。但是读文件方式有四种。如下：

```cpp
ifstream ifs；
ifs.open("test.txt", ios::in);
if( ! ifs.is_open()) { cout << "打开文件失败。" << endl; return;}
char buf[1024] = {0};
//第一种方式
while(ifs >> buf){
	cout << buf << endl;
}
//第二种方式
while(ifs.getline(buf, sizeof(buf))){
    cout << buf << endl;
}
//第三种方式
while(getline(ifs, buf)){
    cout << buf << endl;
}
//第四种当时
char c;
while((c = ifs.get()) != EOF){
    cout << c;
}
ifs.close();
```

#### 二进制文件

##### 写文件

函数原型 ostream& wirte(const char *buffer, int len);

```cpp
Preson p = {"张三"，108}；code
ofs.write((const char*)& p, sizeof(p));
```

##### 读文件

函数原型 istream& read(char *buffer, int len);

```
Person p;
ifs.read((char *)& p, sizeof(p));
cout << "姓名：" << p.m_Name << "年龄：" << p.m_Age << endl; 
```

### 异常

- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。
- **catch:** 在想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常
- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

catch(...) 捕捉任何异常。 括号中可以为基本数据类型和类。

### 右值引用、移动语义、完美转发

右值引用：int &&a  = 10;   不能取地址的为右值，或称为将亡值。可以通过&& 对其引用，右值引用必须初始化，延长了其生命周期同引用变量。

移动语义：在不必要的情况，避免多次复制拷贝，可以通过在对象内重载一个右值引用拷贝，改变指针指向，实现浅拷贝。或者使用std::move()。

完美转发：传进来是右值引用，调用函数传出去也是右值引用。使用std::forward<T>()保留左右值类型，传进来是什么类型，传出去还是。

### sstream

#### stringstream

```cpp
构造函数：
std::stringstream ss;
ss << 100 << " " << 200;
int foo, bar;
ss >> foo >> bar;  //foo:100  bar:200
//stringstream::str
string s = ss.str(); //s = "100 200";
//istream::ignore   //忽略所有输入字符  直到设定字符
char first = std::cin.get();
std::cin.ignore(256, ' ');
char last = std::cin.get();  //输入  "John Smith"  firt = "j"  last = "S"  
int first, second;
    stream<< "456"; //插入字符串
    stream >> first; //转换成int
    std::cout << first << std::endl;
    stream.clear(); //在进行多次转换前，必须清除stream
    stream << true; //插入bool值
    stream >> second; //提取出int
//使用sstream完成字符串分割
string raw_data("3, 4, 5, 76"), tmp;
    vector<string> data;
    stringstream input(raw_data);

    while (getline(input, tmp, ',')) data.push_back(tmp);

    for (auto s : data) cout << stoi(s) << endl;

```

## 程序优化

### 代码方面

字节对齐

条件优化(先判断开销的条件 ++i)

减少拷贝复制(减少调用构造，尽量使用引用)

位运算优化 n<<1  乘以2

### 优化条例

- 良好的算法 和数据结构
- 减少运算强度
- 编译器优化
  - 编译器优化：在编译时使用命令行选项 -finline 展开等”、“-O1”或者更高级别优化等级时
- 乘除法开销较大，尤其除法。避免精度混用。
- 尽量避免内存读写，或者集中写，顺序读
  - 一起使用的函数、变量存储在一起。
  - 合理使用对齐、预取，让一次cache line可以获取更多有效数据。
  - 动态内存分配、STL容器、string都是一些常容易cache不友好的场景，核心代码处尽量不用。
- 函数
  - 形参在栈上开辟，消耗时间。
  - 函数调用，寄存器切换，需要4 clock cycles。
  - 尝试使用inline函数
  - 减少函数间接使用，偏向静态链接而非动态链接，减少多继承、虚继承等。
  - 优先使用迭代而非递归。
- 分支预测
  - if else for while switch 等，使用与 或 位运算，消除判断。

### 工具-整体优化排查

-  vtune  查看cpu time 和汇编指令的消耗
- pm-tools

### [TMAM  自动向下的微架构分析分析方法。](C/C++ 性能优化背后的方法论：TMAM - vivo互联网技术的文章 - 知乎
https://zhuanlan.zhihu.com/p/357699203)

基础理论：将CPU各类微指令进行归类，从大到小分析确认可能出现的瓶颈。

度量方式：cpu时钟周期，cpu pipeline slot 。

在TMAM中最顶层将CPU的资源操作分为四大类，接下来介绍下这几类的含义

1. **Retiring**

它可以用于评估程序对CPU的相对比较真实的有效率。理想情况下，所有流水线slot都应该是"Retiring"。100% 的Retiring意味着每个周期的 uOps Retiring数将达到最大化。

2. **Bad Speculation**

表示错误预测导致浪费pipeline 资源，包括由于提交最终不会retired的 uOps 以及部分[slots](https://www.zhihu.com/search?q=slots&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"357699203"})是由于从先前的错误预测中恢复而被阻塞的。由于预测错误分支而浪费的工作被归类为"错误预测"类别。例如：if、switch、while、for等都可能会产生bad speculation。

3. **Front-End-Boun**

Front-End 职责：

1. 取指令
2. 将指令进行解码成微指令
3. 将指令分发给Back-End，每个周期最多分发4条微指令

优化：

- 宏融合 两条指令和为一条。 循环条件使用无符号等。
- 使用编译器优化选项，优化代码布局。
- 分支与预测优化  (多if else 使用switch case    最可能执行的条件放前边)

4. **Back-End-Bound**

Back-End 的职责：

1. 接收Front-End 提交的微指令
2. 必要时对Front-End 提交的微指令进行重排
3. 从内存中获取对应的指令操作数
4. 执行微指令、提交结果到内存

优化：

- 这一类别的优化涉及到CPU Cache的使用优化,CPU cache[14]它的存在就是为了弥补超高速的 CPU与DRAM之间的速度差距。
- 调整算法减少数据存储，减少前后指令数据的依赖提高指令运行的并发度
- 根据cache line调整数据结构的大小
- 避免L2、L3 cache伪共享

**只有Retiring 类别是越高越好，其他三类都是占比越低越好。如果某一个类别占比比较突出，那么它就是我们进行优化时重点关注的对象。**

[1] CPI（cycle per instruction) 平均每条指令的平均时钟周期个数

[2] IPC （instruction per cycle） 每个CPU周期的指令吞吐数

[3] uOps 现代处理器每个时钟周期至少可以译码 4 条指令。译码过程产生很多小片的操作，被称作微指令(micro-ops, uOps)

[4] pipeline slot pipeline slot 表示用于处理uOps 所需要的硬件资源，TMAM中假定每个 CPU core在每个时钟周期中都有多个可用的流水线插槽。流水线的数量称为流水线宽度。

[5] MIPS(MillionInstructions Per Second)  即每秒执行百万条指令数 MIPS= 1/（CPI×时钟周期）= 主频/CPI

### 代码性能

避免频发申请 释放内存

## 问题整理

### C++11新特性

语法改进：

- 统一的初始化方法
- 成员变量默认初始化
- auto，自动推到定义变量类型
- decltype，求表达式的类型。
- 智能指针  空指针
- 基于范围的for循环  for( : )
- 右值引用和move语义，让程序员有意识减少深拷贝操作。

标准扩充

- 无序容器(哈希表)，用法功能同map，区别在于哈希表效率更高。 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。
- 正则表达式，
- Lambda表达式

### 程序崩溃定位

release版本，生成core文件，gdb查看

-g debug版本，运行定位查找。

[程序崩溃时](https://www.jianshu.com/p/708dca3d27e7)，系统会发送信号，在注册的信号处理函数中，将进程的`maps`文件保存下来，同时记录此时的函数调用链，利用这些信息就可以进行故障定位。添加编译选项`-g`，链接选项`-rdynamic`（**一定要加**）





### C C++区别

- c面向过程 C++面向对象，也可以面向过程
- C++更加安全，增加了引用，四类类型转换、智能指针等。
- 可复用性高，引入了模板的概念，在此基础上实现了STL库。
- C++是不断快速发展迭代的语言，发展了不少新特性 auto、lambda匿名变量、右值引用、智能指针等。
- c默认返回值 int，  C++必须指定 void
- c没有指定参数列表时可以指定任意多的参数，C++没有指定，默认不接受任何参数。 C支持缺省参数
- C++支持函数重载

### 无锁化编程

- 原子操作  多个生产者-消费者也可以使用原子操作(automic)实现无锁化编程
- RCU(Read-Copy-Update)，复制一份进行修改，修改完后使用指针替换，可能线程还在持有旧的副本，所以副本延迟释放。
- CAS，根据值是否发生变化判断是否被修改。

### 空指针调用函数对象

A *p = nullptr;

可以调用不使用成员变量的函数。成员函数的地址在编译时就已经确定。

虚函数不可以调用，因为nullptr没有实例化，还没有生成虚表。

### 迭代器的实现 迭代器失效

将算法和数据容器分开,独立设计.

迭代器是一种智能指针.

**迭代器失效：**

- 对于序列式容器(vetor, deque)使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置，后边每个元素的迭代器都会失效。erase会返回下一个有效的iterator。对删除的迭代器不能在自增运算了，否则会出错。

- 对于关联容器(map, set, multimap, multiset)，删除当前iterator，仅仅会使当前的iterator失效，删除时使用erase(it++)即可。c++11 也会返回下一个有效迭代器。

  map<int, string>::iterator tmpIter =iter; iter++;

   dataMap.erase(tmpIter);

  这几句的意思是,先保留要删除的节点迭代器，再让iter向下一个有意义的节点，然后删除节点。

- 链表型数据结构：使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，不会影响其他迭代器。erase(it++) 或者保存返回值。

统一解决就是：it = erase(*it)  或者erase(it++)

#### gcc分步编译 从代码到可执行二进制文件的过程

- 预处理：宏定义展开，头文件展开，处理条件编译，删除注释在这里并不会做任何语法的检查 gcc -E main.c中（源文件）-o main.i（预处理文件）

- 编译：词法、语法(语法树)、语义分析，代码优化。将预处理后的文件编译成汇编文件   gcc -S main.i（预处理文件）-o mian.s（汇编文件）
- 汇编：将汇编代码转变为机器可执行指令。 gcc -c main.s（汇编文件）-o mian.o（二进制文件）
- 链接：将目标文件链接，生成可执行程序       gcc main.o（二进制文件）-o main.exe（可执行文件）
  - 静态链接：链接时将要调用的函数或过程链接到了生成的可执行文件中，删除静态库也不会影响可执行程序。
  - 动态链接：连接时没有链接进去，在使用中再去寻找，删除动态库，可执行性程序不能运行。

### C实现C++类

- 封装：使用函数体指针把属性和方法封装到结构体中。
- 继承：结构体嵌套。
- 多态：父类与子类方法的函数指针不同。

```cpp
//具体示例
class stack{
public:
    static();
    void push(thing *);
	thing* pop();
private:
    int cnt;
};
Into
struct stack{
    struct stack_type *my_type;
    //可以在这个结构体中 定义私有数据。
};
struct stack_type{
	void (* construct)(struct stack *this );  //构造函数 数据初始化
    struct stack *(* operator_new)();  //创建新的struct 并返回
    void (*push)(struct stack *this, thing *t); 
    thing *(*pop)(struct stack *this);
}Stack = {
	.construct = stack_construct;
    .operator_new = stack_operator_new;
    .push = stack_push;
    .pop = stack_pop;
};
```

```cpp
//多态实现示例
typedef struct sCommClass{ //基类
	int (*open)(struct sCommClass *self, char *fspec);
}tCommClass;
//TCP类
static int tcpOpen(tCommClass *tcp, char *fspec) {
    printf("Opening TCP : %s\n", fspec); return 0;
}
static int tcpInit(tCommClass *tcp) {
    tcp->open = &tcpOpen; return 0;
}
//HTTP类
static int httpOpen(tCommClass *http, char *fspec){
    printf("Opening HTTP: %s\n", fspec); return 0;
}
static int httpInit(tCommClass *http){
	http->open = &httpOpen; return 0;
}
//调用
int main(){
	int status;
    tCommClass commTcp, commHttp;
    tcpInit(&commTcp);
    httpInit(&commHttp);
    status = (commTcp.open)(&commTcp, "bigiron.box.com:5000");
    status = (commHttp.open)(&commHttp, "http://www.microsoft.com");
    return 0;
}
```



### delete this合法吗？

合法，前提是：

- this对象被new分配的，而不是new[]，不是栈上、全局、其他对象成员。
- 保证调用delete this后不再使用这个对象。

### 如何定义一个只能在堆上(栈上)生成对象的类？

限制对象只能在堆上生成：

- 方法：将析构函数设为私有

- 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，如果析构函数不能访问，则不能在栈上创建对象。

  > 当我们将析构函数设置为私有时，意味着析构函数只能在类域中使用，无法被外界(包括自己的对象)调用，表现为：
  >
  > - 禁止用户对此类型的变量进行定义，即禁止在栈内存空间内创建此类型的对象。要创建对象，只能用new在堆上进行。
  > - 禁止用户在程序中delete删除此类型的对象，对象的删除只能在类内进行。即只能按照类的实现者提供的方法。
  >
  > 为什么禁止生成栈对象？或者在堆上生成对象的应用场景：
  >
  > 类的实现者希望，在析构前必须完成一些事情。那么就可以重写一个函数，执行完希望的操作在调用析构函数。而调用者只能使用这个函数析构对象，以达成目的。
  >
  > 将析构函数设置为private除了限制栈对象生成外，还会限制不能作为基类被继承。
  >
  > 如果希望限制栈对象生成，又希望被继承可以使用protect声明析构函数。

限制对象只能在栈上生成：

- 方法：将new和delete重载为私有。
- 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：1.使用new在堆上寻找可用内存，分配给对象；2.调用构造该函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，自然不能在堆上生成对象。(new是一个全局函数)

### 成员函数作为线程的回调函数

推荐使用friend，也可以static 

### memcpy函数实现

```cpp
void * memcpy(void * dest, const void * src, unsigned int count)
{
    if (NULL== dest || NULL == src || 0 == count){ return NULL;}

    char * d;
    const char * s;
    if (dest > (src + count) || dest < src)
    {
        d = (char *)dest;
        s = (char *)src;
        while (count--)
        {
            *d++ = *s++;
        }
    }
    else
    {
        d = (char *)(dest + count - 1);
        s = (char *)(src + count - 1);
        while (count--)
        {
            *d-- = *s--;
        }
    }
    return dest;
}
//创建临时变量去操作
//可能是不同类型，转为char*  
//可能存在空间重叠。
```



### strcpy()函数的缺陷

原型：char * strcpy( char * dst, const char * src );

头文件：string.h

stcpy并不检查目的缓冲区的大小，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续空间，同时加上字符串终止符。

解决：使用strncpy()

char *strncpy(char *dest, const char *src, int n).

表示将src所指向字符串前n个字节复制到dest所指的数组中，并返回复制后的dest。

### 术语辨析

- 函数指针：指向函数的指针。  指针函数：返回指针的函数。
- 数组指针：指向数组的指针。  指针数组：存放指针元素的数组。
- 类模板：用于生成类的模子。  模板类：模板生成的类。

### 杂项

#### [编译原理--语法分析技术简介 ](http://t.csdn.cn/8Msil)  http://t.csdn.cn/RDvZG

#### API、ABI

ABI(Application Binary Interface)定义了编译应用程序需要遵循的一套规则。主要包括基本数据类型，通用寄存器类型的使用，参数传递规则和堆栈使用。

ABI允许支持他的操作系统上的程序不经修改在其他支持此ABI的操作系统上运行。

API(Application programming interface) 源代码级别的接口，编写程序时可以直接拿来用的。

不同：

API定义了源码和库之间的接口，同样的代码可以在支持这个API的任何系统中编译，而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。

##### 保证API兼容的方法：

良好的设计思路

- 面向用例设计，从用户角度出发，保证API设计的易用和合理。
- 保证后续的需求可以通过扩展的形式完成。
- 第一版做尽量少的内容。
- 距离做法：
  - 方法优于属性
  - 工厂方法优于构造函数
  - 避免过多继承
  - 扩展参数应该时便利的

有效的API评审、把握API生命周期、提高可测试性、避免极端意见。

##### ABI兼容

如果引用的库更新了，API和调用方式没变，但是需要重新编译调用源程序，那成为Sourcer compatible；如果不需要重新编译就可以用，就称为二进制兼容的。

保证ABI兼容；

- 遵守调用协定，如windows上所有调用一个函数的地方都要插入清理栈的指令。
- C++ 会使用Name mangling，将函数名字、参数等信息编码成函数签名，用作链接符号，好处是可以在编译期完成检查，避免运行时出现问题。(主要是避免函数重载时的二义性调用)。而不同版本编译器的Name mangling算法不同，所以使用extern c来抑制Name mangling(c不能重载，自然也没这个)，达到开发二进制兼容库的目的。
- 开发二进制兼容的库，避免使用STL，因为不同版本及编译器携带的STL不具备二进制兼容性。
- 内存的分配与释放不应该跨越DLL Boundary(动态连接库的边界)，因为不同模块申请 释放资源方式很大可能不同。

### 注意细节

#### 内存

内存泄漏：程序员在申请内存后，没有及时释放不再使用的内存空间，甚至消灭了指针导致该区域内存空间无法释放，造成内存浪费。

内存溢出：申请的内存空间，不足以供内存申请者使用。比如申请int，存放long型数据。

#### [C++点和箭头操作符用法区别](http://www.cnblogs.com/ManMonth/p/3302873.html)

变量是对象的时候用“.”访问

变量是对象指针的时候用“->”访问

#### 函数的默认参数以及占位参数

- 如果一个位置有了默认参数，那么从这个位置开始，从左往右都必须有默认参数。
- 如果函数声明中出现了默认参数，那么函数实现的时候必须没有。声明和实现只能一个有。
- 占位参数：形如(void fun(int a, int))，函数调用时需要要传入提供这个参数，但是在函数中用不到。主要应用于重载++符号。



smallCookies

- switch()参数为整形，所以只接受能转为整形的参数(char等)，不接受double等实型。

- std::string 不能被继承，因为string的析构函数不是虚函数，会引起内存泄漏。

## Effective

1. 宁可以编译器替换预处理器(尽量以const、enum、inline替换#define)。

2. 尽可能使用const。

3. 确定对象在使用前已经被初始化(构造时赋值(copy构造函数)比defaul构造后再赋值效率高)。

4. 若不想使用编译器自动生成的函数，就应该明确拒绝。(声明为private，并且不予实现)

5. 为多态基类声明virtual析构函数。(如果基类含有虚函数，就应该拥有一个虚析构函数)

6. 别让异常逃离析构函数(析构函数应该吞下不传播异常，或者结束程序而不是吐出异常，如果要处理异常应该在非析构的普通函数中处理。)

7. 绝不在构造函数或析构函数中调用虚函数(因为这类调用不会下降为派生类)。

8. 令operator=返回一个 return &*this，用于连锁赋值。在operator=中处理自我赋值。

9. 赋值对象应确保复制“对象内的所有成员变量”及“所有基类成分”(调用基类复制构造函数)。

10. 以对象管理资源(资源在构造函数获得，在析构函数释放，建议使用智能指针)。

11. 在资源管理类中小心copying行为，(普遍的RALL(Resoures Acquisition Is Initialization) class copying行为是：抑制copying、引用计数、深度拷贝、转移底部资源拥有权)

12. 在资源管理类中提供对原始资源的访问(对原始资源的访问可能经过显式转换或隐式转换，一般而言显式转换比较安全，隐式转换对客户使用比较方便)。

13. 以独立语句将newed对象存储于智能指针(如果不这么做，编译器可能优化，导致难以察觉的资源泄露)。

    processWidght(std::tr1::shared_ptr\<widght>(new Widght), priority());

    C++编译器可能优化，如果priority()调用导致异常，此时new Widght返回的指针尚未被置入shared_ptr(后者是我们期盼用来防止资源泄露的武器。)，那么就会引起资源泄露。

14. 让接口容易被正确使用，而不误用(促进正确使用的方法：接口的一致性、内核类型的行为兼容；阻止误用的方法：建立新类型、限制类型上的操作、约束对象值、消除客户的资源管理责任)。

15. 设计class犹如type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。

16. 宁以pass-by-reference-to-const替换pass-by-value(前者通常更高效、避免切割问题，但不适用于内置类型、STL迭代器、函数对象)。

17. 将成员变量声明为private(为了封装性、一致性、对其读写精确控制)。

18. 宁以non-member、non-friend替换member函数(可增加封装性、包裹弹性、技能扩充性)。

    ```cpp
    eg. (类A)
    void fun1(A& name1){
    	name1.a();
        name1.b();  //通过非成员、非友元函数  进行调用成员函数，增加了封装性
    }
    ```

19. 若所有参数(包括被this指针所指的那个隐喻参数)皆需类型转换，请采用non-memeber函数。

    ```cpp
    //eg 在构造函数不是explict的情况下，一个可以通过编译，另一个不行
    result = oneHalf.operator*(2); //成功
    result = 2.operator*(oneHalf); //错误 只有参数被列于参数列内，这个参数才是隐式类型转换的合格参与者。 这里2不能转化为对应对象，
    //那么让opeartor* 成为一个non-member函数，两个参数都位于参数列表内，就都可以进行隐式类型转换
    const Rational operator*(const Rational& lhs, const Rational& lhs) {}
    result = oneForth * 2;  //成功
    result = 2 * oneForth;  //成功
    ```

20. 考虑写一个不抛出异常的swap函数。

21. 尽可能延迟变量定义式的出现时间(可增加程序清晰度并改善程序效率)。

22. 尽量少做转换类型动作，尽量设计成无需转型、可把转型封装为函数、宁可用新式转型。

23. 避免使用handles(引用、指针、迭代器)指向对象内部(以增加封装性、使const成员函数的行为更像const、降低“虚吊号码牌”(dangling handles, 悬空指针等)的可能性)。

24. 为“异常安全”而努力是值得的(异常安全函数(Exception-safe functions)即使发生异常也不允许泄露资源或允许任何数据结构败坏，如在异常处理中进行资源释放。分为三种可能的保证：基本型、强列型、不抛异常性)。

25. 透彻了解inline的里里外外(inline是编译器行为。inline是否inline取决去编译器，这个关键字只是对编译器的一种建议。大部分编译器拒绝较复杂的函数(如带有循环或递归)inline)，而对所有virtual函数调用(除非是平淡无奇的，必须在没有表现出多态的情况下才有可能)也都会使inline落空；inline造成的代码膨胀可能造成效率损失；inline函数无法随着程序库的升级而升级。

26. 将文件间的编译依存关系降至最低(如果使用object reference或object pointers可以完成任务，就不要使用objects；如果能够，尽量以class声明式替换class定义式；为声明式和定义式提供不同的头文件)。

27. 确定你的public继承塑膜出is-a(是一种)关系(适用于base classes身上的每一件事一定适用于derived classes身上)

28. 避免遮掩继承而来的名字(可使用using声明或转交函数(转交期望数据)来让被遮掩的名字在见天日)。

29. 区分接口继承和实现继承(在public继承之下，derived classes总是继承base class的接口；pure virtual函数只具体指定接口继承；非纯impure virtual具体指定接口继承和缺省实现继承。non-virtual函数具体指定接口继承以及强制性实现继承。)

30. 考虑virtual函数以外的其他选择(如设Template Method设计模式的non-virtual intreface手法，将virtual函数替换为"函数指针成员变量"，以tr1::function成员变量替换virtual函数，将继承体系内的virtual函数替换为另一个继承体系内的virtual函数)。

31. 绝不重新定义继承而来的non-virtual函数。

32. 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定(statically bound)，而virtual函数却是动态绑定(dynamically bound)。

33. 通过复合塑膜has-a(有一个)或“根据某实物实现”。(在应用域，复合意为者has-a(有一个)；在实现域，复合意味着is-implemented-in-terms-of(根据某物实现出))。

    ```cpp
    class Address {};
    class Person {
    private:
    	Address address;   //此为复合，某种类型对象内包含其他类型的对象    
    }; //表示的是has-a 关系， 跟public继承显然是不同的， 不能Person继承一个Address
    //根据某实现，是例如set和map容器，底部都是以红黑树结构实现的，那么就有is-implemented-in-terms-of的意义。
    ```

34. 明治而审慎地使用private继承(private继承意味着is-implemented-in-terms-of(根据某物实现出)，尽可能使用复合，当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数，或需要empty base最优化时，才使用private继承)。

35. 明治而审慎地使用多重继承(多继承比单一继承复杂，可能导致新的歧义性，以及对virtual继承的需要，但确有正当用途，如"public"继承某个interface class和"private"继承某个协助实现的class。virtual继承可以解决多继承下菱形继承的问题，但是会增加大小、速度、初始化以及赋值的复杂度等等成本)。

36. 了解隐式接口和编译器多态(class和templates都支持接口(interfaces)和多态)；class的接口时以签名为中心的显示的(参数列表已经确定的)，多态则是通过virtual函数发生于运行期。template的接口是基于有效表达式的隐式的(implicit)(根据传入的值，进行隐式转换)，多态则是通过template具现化和函数重载解析。

    运行期多态：virtual函数只有个在运行期才能确定具体身份。  

    编译器多态：函数的重载、泛型的具体化。

37. 了解typename的双重意义，(声明模板(template)类型参数时，前缀关键字class和typename的意义完全相同；使用关键字typename标识嵌套从属类型名称，但不得在基类列或成员初值列内以他作为基类修饰符)。

38. 学习处理模板化基类内的名称(可在derived class templates内通过this->指涉base class template内的成员名称，或藉由一个明白写出的base class资格修饰符完成)。

    代码如下，默认是无法判断从哪里继承，加上修饰，明确告知编译器 这个函数存在。

    ```cpp
     class CompanyA
     { public:
          void SendClearText(){}
          void SendEncryptedText(){}
     };
     class CompanyB
     {  public:
         void SendClearText(){}
         void SendEncrypedText(){}
     };
     template <class Company>
     class MsgSender
     { public:
         void SendClearText() {}
     };
     template <class Company>
     class MsgSenderWithLog: public MsgSender<Company>
     { public:
        	using MsgSender<Company>::SendClearText; //告诉编译器，请他假设SendClearText位于base class内
      		void SendClearTextWithLog() {
             //SendClearText(); // 有的编译器会编不过这段代码  编译器不知道继承怎样的类
             this->SendClearText();//成立
         }
     };
     int main()
     {
         MsgSenderWithLog<CompanyA> MsgSender;
         MsgSender.SendClearTextWithLog();
     }
    ```

39. 将与参数无关的代码抽离templates。

    - 因类型模板参数(non-type template parameters)而造成代码膨胀往往可以通过函数参数或class成员变量替换template参数来消除。

      ```cpp
      template<typename T, int n>
      class Square{   //Square替换为SquareBase
      public:
      	void invert();
      };
      Squre<double, 5> s1; Square<double, 10> s2; Square会实例化两个类。
      //改为如下
      template<typename T, int n>
      class Square:private SquareBase<T>{
      private:
          using SquareBase<T>::invert;
      public:
          void invert(){ this->invert(n); }  //调用代价为0，因为是隐式内联函数。隐式的办法便是把函数定义放在类的定义中：
      }；//这样在实现上述实例化时，共享一份invert函数。
      //使用this->前缀是因为SquareBase里的名称在子类模板Square里是隐藏的。 父类模板中的名称对子类模板不是直接可见的，需要this->或using。如38解释，父类模板在实例化之前其中的名称是否存在确实是不确定的。
      //private继承和对象组合类似，可以表示has-a(组合)的关系。组合具有更大灵活性，能组合就不要使用private。
      //private和public的不同之处：
         用private 编译器不会把子类对象转为父类对象。//private继承的子类数据访问权限和父类不同。
      ```

    - 因参数类型而造成的代码膨胀往往可以通过让带有完全相同二进制表述的实现类型共享实现码。如vector\<int>和vector\<long>  int 和long 二进制码一样，四字节

# 实习

## YUV与RGB

RGB:红蓝绿三原色。1080p图片，信息量“1920\*1080\*3/1024/1024 = 7M

YUV:采用明亮度和色度表示每个像素的颜色。Y表示亮度(灰阶值)，U、V表示色度。（兼容黑白电视）

RGB到YUV可以互转。

# 算法

## 排序

| 排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       | 适用场景                                                     |
| -------- | -------------- | -------------- | ---------- | -------------------- | ------------------------------------------------------------ |
| 冒泡     | O(n^2^)        | O(n^2^)        | O(1)       | 稳定                 |                                                              |
| 选择     | O(n^2^)        | O(n^2^)        | O(1)       | 数组不稳定、链表稳定 |                                                              |
| 插入     | O(n^2^)        | O(n^2^)        | O(1)       | 稳定                 | 基本有序的数列，或较小数据量                                 |
| 快排     | O(n*log~2~n)   | O(n^2^)        | O(log2n)   | 不稳定               | 大量数据。注意随机，防止选择pivot为最大值或最小值退化为选择排序，时间复杂度不稳定 |
| 堆排     | O(n*log~2~n)   | O(n*log~2~n)   | O(1)       | 不稳定               | 时间复杂度较稳定                                             |
| 归并     | O(n*log~2~n)   | O(n*log~2~n)   | O(n)/O(1)  | 稳定                 | 链表适合使用，时间复杂度稳定，自底向上空间复杂度O(1)         |
| 希尔     | O(n^(1.3~2)^)  | O(n^2^)        | O(1)       | 不稳定               | 注意选择合适的步长，改进的插入排序                           |
| 计数     | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 | 数列都为整数，最大值与最小值差值不宜过大，一般0-100内，比所有比较排序都快。 |
| 桶排     | O(n)           | O(n)           | O(m)       | 稳定                 |                                                              |
| 基数     | O(k*n)         | O(n)           |            | 稳定                 | 适合都为整数或负数，否则处理麻烦                             |

> - 均按照从小到大排列
> - K：代表数值中的"数位"个数
> - n：代表数据规模
> - m：代表数据的最大值减最小值



数据对象稳定性：排序后，在原始数组中(相同元素)相对次序不改变。

选择排序不稳定：例如10，6，8，6。这里第二个6通过第一趟遍历选择，通过交换变到了第一个6的左边，相对位置发生变化。

插入排序实践中要比选择排序快一倍，在倒置对象较少时，可能比常见其他算法都快。

基数排序与[计数排序](https://so.csdn.net/so/search?q=计数排序&spm=1001.2101.3001.7020)、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

> - 基数排序：根据键值的每位数字来分配桶；
> - 计数排序：每个桶只存储单一键值；
> - 桶排序：每个桶存储一定范围的数值；

<a name = "内省排序">内省排序:首选从快速排序开始，当递归深度超过一定深度(深度为排序元素数量的对数值)后转为堆排序。可以在常规数据集上实现快排的高性能，又可以在最坏情况下保持O(nlogn)的时间复杂度。属于比较排序。</a>

希尔排序，选择步长是重要的一部分。默认n/2,比O(n^2^)类的算法更好，但是仍有减少平均时间和最差时间的余地。再中小数组中甚至比快排和堆排还要快的步长(1, 5, 19, 41, 109,...)![image-20220506101428873](资料整理.assets/image-20220506101428873.png)。大数组较好的序列是![image-20220506101406010](资料整理.assets/image-20220506101406010.png)

类别：

- 比较类排序
  - 交换排序
    - 冒泡排序
    - 快速排序
  - 插入排序
    - 简单插入排序
    - 希尔排序
  - 选择排序
    - 简单选择排序
    - 堆排序
  - 归并排序
- 非比较类排序
  - 计数排序
  - 桶排序
  - 基数排序

### 堆排序：排升序为什么使用大顶堆？

堆实现是一个完全二叉树，排序后应该是从根节点依次层序遍历，值随着递增。而堆每次确定大小只有堆顶元素。如果排序使用小顶堆，第一次建堆，选择出最小元素，最小元素正确位置就是堆顶，那么堆顶元素不能更改了，就无法找到第二小的元素了。如果把堆顶元素取出，没有堆顶元素，堆的性质改变，只能重新建堆。

具体实现流程：排升序，建立大顶堆，堆顶元素此时最大，堆顶元素与堆尾互换，最大元素在堆尾已经确定，下次堆顶元素与堆尾-1互换，确定第二小元素，依次类推，建立升序。

## [栈的应用——四则表达式求值](../essential/SimpleCodeForApply/SiZeYunSun.cpp)

后缀(逆波兰)表示法定义:

不需要括号的的后缀表示法，例：$9+(3-1)×3+10÷2$，后缀表达式为9 3 1 - 3 * + 10 2 / +

计算规则

从左到右遍历表达式的每个数字和符合，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈进行对应运算，运算结果进栈，一直到最终获得结果。

平时所用的标准四则运算表达式，即$9+(3-1)×3+10÷2$称为`中缀表达式`。

中缀表达式传为后缀表达式规则：

> 从左到右遍历中缀表达式的每个数字和符号，若是数字就先输出，即成为后缀表达式的一部分。若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。
>
> （1）自左向右顺序扫描整个中缀表达式；
>
> 如果当前元素为操作数，则将该元素直接存入到后缀表达式中；
>
> 如果当前元素为“(”，则将其直接入栈；如果为“)”，则将栈中的操作符弹栈，并将弹栈的操作符存入到后缀表达式中，直至遇到“(”，将“(”从栈中弹出，并不将其存入到后缀表达式中；
>
> 如果是其他操作符，如果其优先级高于栈顶操作符的优先级，则将其入栈，如果是小于或低于栈顶操作符优先级，则依次弹出栈顶操作符并存入后缀表达式中，直至遇到一个栈顶优先级小于当前元素优先级时或者栈顶元素为“(”为止，保持当前栈顶元素不变，并将当前元素入栈；
>
> （2）当扫描完毕整个中缀表达式后，检测操作符栈是否为空，如果不为空，则依次将栈中操作符弹栈，归入后缀表达式。
> 

## 查找

顺序查找

二分查找

斐波那契查找   每次取黄金比例0.618靠后的位置。

插值查找   适合等差数列  mid = left + (key - iList[left]) * (right - left) // (iList[right] - iList[left])

### 分块查找

又称索引查找，吸取线性查找和折半查找各自的优点。既有动态结构，又有快速查找。

基本思想：将查找表分为若干块，块内可以无序，块之间要有序。

查找过程：折半查找待查找的索引块。  在块内顺序查找.

平均查找长度：索引查找和块内查找的平均长度之和。最小为： sqrt(n) + 1。

## 动态规划

思想：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果，与贪婪算法不同的是，在贪婪算法中，每采用一次贪婪准则，便做出一个不可撤回的决策；而在动态规划算法中，还要考察每个最优决策序列中是否包含一个最优决策子序列，即问题是否具有最优子结构性质。

  动态规划算法的有效性依赖于待求解问题本身具有的两个重要性质：最优子结构性质和子问题重叠性质。**不论初始状态和初始决策如何，对于前面决策所造成的某一状态而言，其后各阶段的决策序列必须构成最优策略**”。

## 树

### Kruskal算法

每次加入权值最小边，直到有V-1，且没有环。   适合稀疏图。

### Prim算法

每次找距离已加入集合中，最近的点。			适合稠密图。

### Dijkstra

前两个为最小生成树，这个为找当前点，到其他点最短距离。



# 其他杂项

## 设计模式

## 什么是设计模式？

每一种模式描述了一个在我们周围不断重复的问题，以及该问题，解决方案的核心，这样就可以一次一次使用该方案而不必做重复劳动。

> 如何解决复杂性？ 分解、抽象。

## 设计原则

1. 单一原则

   - 一个类或者一个方法只负责一项职责。
   - 一个类应该仅有一个引起它变化的原因。

2. 里氏(Liskov)替换原则

   - 子类必须能够替换它们的基类。

   - 继承表达抽象类型。

     > 里氏替换原则是对开闭原则的补充，开闭原则关键就是抽象化，而基类与子类继承关系就是抽象化的具体实现，所以里氏替换是对实现抽象化的具体步骤的规范。

3. 依赖倒置原则
   - 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。
   - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。
   
4. 接口隔离原则

   - 不应该强迫客户程序以来他们不用的接口。

   - 接口应该小而完备。

     > 使用多个隔离的接口比单个的要好，思想还是降低耦合、依赖。

5. 迪米特原则(最少知道原则)

   - 一个类实体应当尽量的与其他实体之间发生作用，使得模块相对独立。(尽量降低权限)

6. 开闭原则

   - 对扩展开发，对更改封闭。
   - 类模块应该是可扩展的，但是不可修改。

面向对象原则在以上基础上增加：

7. 优先使用对象组合，而不是类继承
8. 封装变化点。使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
9. 针对接口实现编程，而不是针对实现编程。

## 分类

### 经典分类

- 创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
- 结构性模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- 行为型模式：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 封装变化角度对模式分类

- 组件协作：模板方法模式、观察者模式、策略模式。
- 单一职责：装饰器模式、桥接模式。
- 对象创建：工厂方法模式、桥接模式、抽象工厂模式、原型模式、建造者模式。
- 对象性能：单例模式、享元模式。
- 接口隔离：外观模式(门面模式)，代理模式、中介者模式、适配器模式。
- 状态变化：备忘录模式、状态模式。
- 数据结构：组合模式、迭代器模式、责任链模式。
- 行为变化：命令模式、访问者模式。
- 领域问题：解释器模式。

### 详解

#### 单例模式

定义：保证一个类仅有一个实例，并提供一个该实例的全局访问点。

饿汉：在类被加载时就实例化一个对象。

懒汉：仅在需要该对象时才进行实例化。

notes: 构造函数是私有的，只有创建实例的指针是共有。

#### 策略模式

定义：定义一系列算法，把他们封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而改变。也就是这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略引起环境角色表现出不同的行为。

优点：消除了大量的判断语句，降低复杂度，解耦合。如果Startegy对象没有实力变量，各个上下文可以共享一个对象，节省对象开销。

缺点：可能要定义大量策略类，并且客户端必须知道所有的策略类，并自行决定使用哪个策略类。

构成：

- Stragety(策略的对象，接口)

- ConcreteStrategyA, ConcreteStrategyB...(具体的策略实现类)

- Context(用来操作策略的上下文环境类)：环境类的构造函数包含了Strategy类，通过多态传进来不同的具体策略(ConcerteStrategyA, StrategyB)来调度不同策略的方法。

  ![image-20220410215840579](资料整理.assets/image-20220410215840579-16495991220085.png)

#### 观察者模式

定义：属于行为模式的一种，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在发生变化时，会通知所有的观察者对象，使他们能够自动更新自己。

构成：

- Subject(抽象被观察着，主题对象)：将所有观察者对象保存到一个集合里(通常是ArrayList)，主题可以拥有任意数量的观察者，抽象主题提供增加、删除观察者对象的接口(attach, detach)。

- Observer(抽象观察者)：定义了一个更新接口的方法(update)，使得在得到主题更改通知时更新自己。

- ConcreteSubject(具体被观察者): 有关状态保存在具体观察者对象,具体观察者对象的内部发生变化时,给所有加入过的观察者发送通知.

- ConcreteObserver(具体观察者): 实现抽象观察者定义的更新接口,以便在得到主题更改通知时更新自身的状态.

  ![image-20220410211016203](资料整理.assets/image-20220410211016203-16495962176214.png)

#### 工厂模式

定义:定义一个用于创建对象的接口,让子类决定实例化哪一个类,使得类的实例化延迟到子类.

要点总结:用于隔离类对象的使用者和具体类型之间的耦合关系. 解决"单个对象"的需求变化,缺点是要求创建方法/参数相同.

简单工厂: 需要在工厂类中进行判断,创建相应的产品,增加新的产品时,就需要修改产品类.![image-20220411100330796](资料整理.assets/image-20220411100330796-16496426129177.png)

简单工厂,在增加新的产品时,需要修改工厂类,违反了开放封闭原则.于是工厂模式出现了,工厂模式是定义一个用于创建对象的接口,让子类决定实例化哪一个子类.

![image-20220411100842897](资料整理.assets/image-20220411100842897-16496429240809.png)

#### 抽象工厂模式

定义:提供一个接口,让一个接口负责创建一系列"相关或者相互依赖的对象",无需指定他们具体的类.

系列对象是指在一个特定系列的对象之间有相互依赖,或者相互作用的关系.

抽象工厂主要应用于"新系列的需求变动",缺点在于难以应对"新对象"的需求变动.

![image-20220411103136820](资料整理.assets/image-20220411103136820-164964429873810.png)



#### 外观模式

定义:为子系统中的一组接口提供一个稳定的界面,外观模式定义了一个高层的接口,这个接口使得这一子系统更加容易使用(复用).

注意:外观模式并非是一个集装箱,可以任意放进任何多个对象,外观模式内部应该是"相互耦合关系较大的一系列组件",而不是一个简单的功能的集合.

![image-20220411104638833](资料整理.assets/image-20220411104638833-164964520159511.png)

#### 组合模式

定义:将对象组合成树形结构以表示"部分-整体"的层次结构.组合模式使得用户对单个对象和组合对象的使用具有一致性(稳定).

优先使用组合 contains a（聚合 has a）， 而不是继承is a来达到目的.

动机: 继承会讲实现细节暴露给子类,继承复用破坏了封装性,是白箱复用.使用继承需要考虑里氏替换原则.

优点:新类对象存取成员只通过成员对象的接口,是黑箱复用,系统更灵活,降低耦合度,可以在运行时动态进行.

组成元素:

- 抽象构建角色: 是组合对象声明接口,实现所有类共有接口的默认行为.
- 树叶构建角色: 叶节点没有任何子节点,实现了抽象构建角色中某些行为.
- 树枝构建角色: 实现了抽象构建角色的所有操作,并且持有子节点对象.

![image-20220411113211695](资料整理.assets/image-20220411113211695.png)

#### 迭代器模式

动机: 集合对象内部结构常常变化异常,但是对于这些集合对象,我们希望在不暴露其内部结构的同时,可以让外部客户代码透明地访问其中包含的元素;同时这种"透明遍历"也为同一种算法在多种集合对象上进行操作"提供了可能".

定义: 按照一种方法顺序访问一个聚合对象中的各个元素,而又不暴露(稳定)该对象的内部表示.

注意:对C++来说是过失的,现在迭代器用模板实现,面向对象的方式性能低.观察

## 正则表达

| 字符 | 描述                                                      | 字符    | 描述                                 |
| ---- | --------------------------------------------------------- | ------- | ------------------------------------ |
| $    | 匹配输入字符串的结尾位置                                  | [...]   | 匹配[]所有字符(以单个字符为单位匹配) |
| .    | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 \[^\n\r] | [\^...] | 匹配除了[]中以外的字符               |
| \s   | 匹配空白符                                                | [A-Z]   | 表示A-Z所有字母                      |
| \S   | 匹配除空白符外字符                                        | +       | 一次或多次                           |
| \w   | 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]               | *       | 零次或多次                           |
| $    | 匹配输入字符串的结尾位置                                  | ?       | 零次或一次                           |
| ( )  | 标记一个子表达式的开始和结束位置.(参数变量可以获取)       | \|      | 或                                   |

##  软件工程

### [UML图](http://t.csdn.cn/RoapM)

UML图分为结构图和行为图

- 结构图分为：类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。
- 行为图分为：活动图、状态机图和交互图。
  - 交互图分为：时序图、序列图、通讯图、交互概览图。



# 数据库

## MySQL

[码、候选码等基本概念定义](http://t.csdn.cn/5rYDC)

数据类型：

### 数据库索引类型

索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引并非如此。聚簇索引可以提高多行检索的速度，而非聚簇索引对于单行检索很快。

使用索引的好处是，查找符号条件的选项不用全部遍历，可以直接定位。

- 普通索引：create index index
- 唯一索引：索引的值必须唯一，但是允许空值。如果

## SQL

在使用 **left jion** 时，**on** 和 **where** 条件的区别如下：

- 1、 **on** 条件是在生成临时表时使用的条件，它不管 **on** 中的条件是否为真，都会返回左边表中的记录。
- 2、**where** 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 **left join** 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。
- ![image-20220417202003117](资料整理.assets/image-20220417202003117.png)

MySQL的锁级别有以下三种：行级、表级、页级。

| 类型   | 开销 | 加锁速度 | 是否会发生死锁 | 锁定粒度 | 锁冲突概率 | 并发度 |
| ------ | ---- | -------- | -------------- | -------- | ---------- | ------ |
| 行级锁 | 大   | 慢       | 会             | 最小     | 最低       | 最高   |
| 表级锁 | 小   | 快       | 不会           | 最大     | 最高       | 最低   |
| 页级锁 | 适中 | 适中     | 会             | 适中     | 适中       | 适中   |



## Redis

### 限流

目的：为了不保证系统不被巨大的流量压垮，会在系统流量达到一定的值得时候，拒绝掉一部分流量。

限流方案：

- 漏桶算法：把水比作是请求，漏桶容量比作是系统处理能力的极限，水先进入到漏桶，然后按照漏斗处一定速率流出，当流入速率大于流出速率，多出得水会溢出(拒绝请求)。
- 令牌桶：系统维护一个令牌，如果有一个请求进来，需要被处理，需要先在桶里获取一个令牌，当桶里没有令牌时，将拒绝请求。通过控制令牌桶的容量以及发放令牌的速率，来达到对请求的限制。
- Redis + Lua：Lua脚本指定一组命令要不全部成功要不全部失败，以达到原子性。
  - Lua脚本优点：减少网络开销，无需多次向Redis发送请求，执行一次就可，减少网络传输。原子操作。复用：一旦执行可以永久保存，供其他客户端使用。
- 网关层限流：如Nginx

# 计算机网络

## TCP/IP网络模型

- 应用层：只关心为用户提供各种功能服务，需要通信将给运输层。工作在用户态，其他层都工作在内核态。

- 传输层：为应用层提供网络支持，完成应用到应用的通信。具有TCP和UDP协议，分别是面向连接的可靠传输，无连接的不可靠传输，提供不同的支持。

- 网络层：完成实际的在网络上传输的功能。最常用的是IP协议。

- 数据链路层：为网络层提供链路级别传输的服务，根据IP地址找到对设备传输。

- 物理层：把数据转为电器信号，让其可以在物理介质中传输，为数据链路层提供二进制传输服务。

  ![img](资料整理.assets/56600133_1589697172563_DD4984C5FA34311A038C312D29C3C0AA-165061397139812.png)

  ![img](资料整理.assets/5293318_1597969294204_2BCFB688681219DFEA13483621BB4418-165061401687414.png)

### TCP

TCP是面向连接的、可靠的、基于字节流的传输通信层协议。

面向连接：一对一。字节流：没有边界，多大都可以传输，有序的。

TCP工作在传输层的可靠数据传输的服务，保证接收端是无损坏、无间隔、非冗余和按序的。

![image-20220422095510488](资料整理.assets/image-20220422095510488-16505925118189.png)

TCP连接：保证可靠性和流量控制的的某些状态信息。这些信息包含socket、序列号和窗口大小。

TCP四元组确定一个连接：<源地址、源端口、目的地址、目的端口>

UDP头部8个字节，源端口号、目的端口号、包长度、校验和各2字节。

#### TCP和UDP区别：

- 连接：TCP面向连接、UDP无连接。
- 服务对象：TCP一对一，UDP一对一、一对多、多对多。
- 可靠性：TCP可靠交付数据，数据无差错、不丢失、有序、不重复到达。UDP尽最大努力交付。
- TCP具有流量、拥塞控制，保证数据传输安全性，UDP没有，发送速率不会影响。
- 首部开销：TCP最短20字节，UDP固定8个字节。
- 传输：TCP流式传输、没有边界但是有序、可靠。UDP有边界，可能丢包、乱序。
- 分片：数据大小大于MSS(最大报文长度)大小，在传输层分片。UDP大于MTU(数据链路层)，IP层分片，UDP应小于MUT。
- 应用场景：TCP：文件传输、HTTP。 UDP：DNS、SNMP、音视频、广播。

#### 三次握手

![image-20220422110856199](资料整理.assets/image-20220422110856199-165059693767710.png)

Linux中查看TCP状态：netstat -napt

##### 为什么是三次握手而不是两次？

- 三次握手才可以阻止重复历史连接的初始化。(收到服务器对旧连接的Ack确认，发起RST报文终止旧连接。)

- 三次握手才可以同步双方的初始序列号。

  - 序列号可以去掉重复的数据。

  - 可以按序接收。

  - 标识发送出去的数据包那些是已经被接受的。

    四次也可以，但是第二部的确认ack和syn可以合为一个。

    两次握手只可以保证一方序列号被正确接收。

- 避免资源浪费。

  如果客户端syn请求连接被阻塞，客户端没有收到ack报文，就会重新发送syn。而服务器不知道客户端是否收到建立连接的ack确认信号，所以syn只能

#### TCP四次挥手

![image-20220424093625306](资料整理.assets/image-20220424093625306-16507641869952.png)

MSL：报文最大生存时间。而TTL是IP头部字段，指定IP数据包可以经过的最大路由跳数。

close_wait 代码问题：查代码**判断read，一旦读到0，断开连接**，**read返回负，检查一下errno，如果不是AGAIN，就断开连接。**



##### time_wait

1.TCP 连接建立后，「主动关闭连接」的一端，收到对方的 FIN 请求后，发送 ACK 响应，会处于 time_wait 状态； Linux默认MSL30，2MSL60秒。

2.time_wait 状态，存在的必要性：

**a、** 保证被动关闭连接一方可以正确关闭：四次挥手关闭 TCP 连接过程中，最后的 ACK 是由「主动关闭连接」的一端发出的，如果这个 ACK 丢失，则，对方会重发 FIN 请求，因此，在「主动关闭连接」的一段，需要维护一个 time_wait 状态，处理对方重发的 FIN 请求；

**b、** 处理延迟到达的报文：由于路由器可能抖动，TCP 报文会延迟到达，为了避免「延迟到达的 TCP 报文」被误认为是「新 TCP 连接」的数据，则，需要在允许新创建 TCP 连接之前，保持一个不可用的状态，等待所有延迟报文的消失，一般设置为 2 倍的 MSL（报文的最大生存时间），解决「延迟达到的 TCP 报文」问题。以及可能存在延迟到达的四元组相同的RST报文，造成意外关闭。

3.过多time_wait的危害

- 对内存资源的占用。

- 对端口资源的占用，一个TCP连接至少消耗一个本地端口。

  一般可以开启端口为32768~61000。可以通过net.ipv4.ip_local_port_range指定。

  客户端受端口资源限制：

  ​	如果发起连接一方time_wait状态过多，占满了所有端口资源，将无法发起新连接。

  服务端受系统资源限制：

  ​	由于一个四元组表示一个TCP连接，理论上可以建立很多连接，服务端确实只监听一个端口，但是会把连接交给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理能力是有限的，当服务端出现大量time_wait时，系统资源被占满时，会导致处理不过来新的连接。

4.[大量time_wait解决办法](https://www.cnblogs.com/dadonggg/p/8778318.html)：

- net.ipv4.tcp_tw.reuse和tcp_timestamps:star:

  net.ipv4.tcp_tw.reuse = 1，开启后，可以复用处于time_wait的socket为新的连接所用。需要注意的是，只能用于客户端(连接发起方)，因为开启后，在调用connect()函数时，内核会随机找一个time_wait状态超过1秒的连接给新的连接复用。前提时需要开启时间戳。由于引入了时间戳，2MSL问题就不存在了，重复的数据包会因为时间戳过期被丢弃。

- net.ipv4.tcp_max_tw_buckets❌

  这个值默认18000，系统中处于time_wait超过这个值时，系统会将后边的time_wait状态重置。但是治标不治本，而且带来问题的远比解决的问题多，不建议使用。

- 使用SO_LINGER❌

  ```cpp
  struct linger so_linger;
  so_linger.l_onoff = 1;
  so_linger.l_linger = 0;
  setsockopt(s, SOL_SOCKET,, SO_LINGER, &so_linger, sizeof(so_linger));
  ```

  l_onoff为非0，且l_linger值为0，调用close后会立刻发送一个RST标志给对端，该TCP连接将跳过四次挥手，也就跳过了time_wiat状态，直接关闭。但是非常危险。

- 修改内核参数 /etc/sysctl.conf

  ```c
  net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
  net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； 开启后客户端(发起方)调用connect时，内核会随机找一个time_wiat状态找过一秒的连接给新的连接复用，适用于连接发起方。
  net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
  执行 /sbin/sysctl -p 让参数生效.
  ```

  简单来说就是快速回收和time_wait重用。

  如果上述不理想，还可以

  ```cpp
  vi /etc/sysctl.conf
  net.ipv4.tcp_keepalive_time = 1200 
  #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
  net.ipv4.ip_local_port_range = 1024 65000 
  #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
  net.ipv4.tcp_max_syn_backlog = 8192 
  #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
  net.ipv4.tcp_max_tw_buckets = 5000 
  net.ipv4.tcp_fin_timeout  修改系統默认的TIMEOUT时间
  #表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
  默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
  ```

  #对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间  
  
  net.ipv4.tcp_syn_retries=2 
  
  #net.ipv4.tcp_synack_retries=2 
  
  #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒 
  
  net.ipv4.tcp_keepalive_time=1200 
  
  net.ipv4.tcp_orphan_retries=3 
  
  #表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间 
  
  net.ipv4.tcp_fin_timeout=30   
  
  #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。 
  
  net.ipv4.tcp_max_syn_backlog = 4096 
  
  #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭 
  
  net.ipv4.tcp_syncookies = 1 
  
     
  
  #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 
  
  net.ipv4.tcp_tw_reuse = 1 
  
  #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 
  
  net.ipv4.tcp_tw_recycle = 1 
  
     
  
  ##减少超时前的探测次数  
  
  net.ipv4.tcp_keepalive_probes=5  
  
  ##优化网络设备接收队列  
  
  net.core.netdev_max_backlog=3000  
  
  　　修改完之后执行/sbin/sysctl -p让参数生效。
  
  net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。
  
  net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。
  
  net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。
  
   
  
   修改方法：
  
   
  
  sudo vi /etc/sysctl.conf
  
   
  
  增加如下：
  
   
  
  net.ipv4.tcp_tw_reuse = 1 
  
  net.ipv4.tcp_tw_recycle = 1 
  net.ipv4.tcp_fin_timeout = 30 
  net.ipv4.ip_local_port_range = 10000 65000 
  net.ipv4.tcp_max_syn_backlog = 8192 
  net.ipv4.tcp_max_tw_buckets = 10000
  
   
  
  sudo /sbin/sysctl -p
  

#### TCP可靠性保证

重传机制、滑动窗口、流量控制、拥塞控制。

##### 重传机制

- 超时重传

  发送方超过指定时间后，没有收到接收方的ack确认报文，会重新发送。发生在数据包丢失和确认应答丢失。超时重传RTO时间略大于RTT值。

- 快速重传

  超时重传时间可能较长，可以使用快速重传。发送端收到到了三个相同的ack报文，会在超时重传时间之前，重传丢失的报文。但是不知道是进重传ack期望收到的报文还是后续全部，所以出现了SACK。

- SACK(选择性确认)

  在TCP头部选项字段加一个SACK，它可以将缓存的地图发送给对方，就知道了那些收到，那些没收到。

  SACK 300~400 代表收到了300~400段报文。

- D-SACK

  使用SACK告诉发送方有哪些数据被重复接收了。

  例如ACK丢包：ACK = 4000， SACK = 3000 ~ 3500，SACK小于ACK，此时代表D-SACK，收到了重复报文，说明接收方ACK报文丢失，造成超时重传。

  网络延时：数据包(1000\~1499)被网络延迟，发送端收到三个相同的ACK确认报文，发送端进行快速重传，重传后，接收方收到了延迟的的报文，ACK3000，SACK(1000~1500)表明是D—SACK，发送方知道，快速重传触发原因是网络延迟了。

  好处：

  - 让发送方知道是发送出去的数据包丢了，还是接收方回应的ACK包丢了。
  - 可以知道发送方的数据包是不是网络延迟了。
  - 网络中是不是把发送方的数据包复制了。

##### 滑动窗口

引入原因是，发送一个确认一个，效率低下，存在队头阻塞。

定义：在操作系统开辟一个指定大小的缓存空间，无需等待确认应答，可以发送窗口大小个报文，未收到接收方确认应答前，必须在缓冲区保留已发送数据，从第一个已发送，但是未收到ack确认开始，如果按期收到确认应答，可以从缓冲区清除。

分为四部分

- 已发送已收到，已经收到确认的数据，这部分已经从滑动窗口中清除。
- 已发送未收到，从未收到确认的数据第一个开始，要保留。
- 未发送窗口内，但总大小在接收方处理范围内，可用窗口。
- 未发送hu，但总大小超过接收方处理范围，等待加入窗口。

**窗口关闭潜在的危险**

一旦发送方收到接收方窗口大小为0的报文，发送方不再发送数据。接收方处理完数据，窗口打开，给发送方一个窗口大小非0的报文。如果这个报文丢失了，通信双方僵持一直互相等待下去。造成死锁现象。

实际如何解决的：一旦窗口关闭，会启动定时器进行探测窗口大小，持续三次窗口大小为0，发送RST中断TCP连接。

**糊涂窗口综合征**

概念：接收方太忙，来不及处理缓冲区数据，发送窗口越来越小，到最后，接收方腾出几个字节就告诉发送方，发送发义无反顾发送这个字节大小的数据。TCP+IP头部最少40字节，每次只传输几字节的的数据，就会造成巨大网络资源浪费。

问题出现在：

- 接收方通告的窗口过小。
- 发送方对应的发送数据过小。

解决办法：

- 窗口大小小于min(缓冲大小/2, MSS)，通告窗口大小为0，窗口大小大于上述条件时，通告实际窗口大小。

- 发送方思路是，延迟处理。满足以下至少其中之一才可以发送数据。Nagle算法

  - 窗口大小大于等于MSS
  - 收到之前数据的ACK确认报文

  Nagle算法默认打开，对于ssh、telnet交互性较强的程序，需要关闭。setsockopt

##### 流量控制

避免发送方发送数据速率太快，超过接收方处理速度，而导致被迫丢弃数据包，造成流量浪费。

使用动态的滑动窗口，使发送方发送速率在接受方可以接受范围内。

需要注意的是：不允许同时减少缓存又收缩窗口的，而是先收缩窗口，过段时间再减少缓存，避免丢包。

##### 拥塞控制

流量控制避免发送太快，导致接受方来不及接收。

拥塞控制是避免发送太快，导致网络拥堵。

为了调节发送的量的大小，定义了拥塞窗口的概念。cwnd。

**什么是拥塞窗口，和发送窗口的关系？**

拥塞窗口是发送方维护的一个状态变量，根据网络的拥塞程度进行调整。

发送窗口大小swnd = min(cwnd， rwnd)。rwmnd是接收窗口大小。

如何探测是否发生了拥塞？ 是否有超时重传。

拥塞控制算法：

- 慢启动

  每收到一个ack，cwnd加一，发包个数是2，4，8指数性增长，直到增长到ssthresh(slow start threshold)慢启动门限，大于门限时，启用拥塞避免算法。一般时65535

- 拥塞避免

  每收到一个ack，cwnd增加1/cwnd，发包个数线性增长。表现为依次加一。直到发生了丢包检测到了拥塞。

- 拥塞发生

  超时重传

  - 情况严重所以，cwnd置为1，sstresh降为cwnd/2，然后继续开始慢启动。

  快速重传

  - 波动变化较低，cwd = cwd / 2， sstresh = cwd，然后进入快速恢复。

- 快速恢复

  - 拥塞窗口cwnd = sstresh + 3 （3是确认有个三个数据包收到了）
  - 重传丢失的数据包。
  - 收到重复的ack，cwnd再加+1，（原本加3）
  - 收到新数据的ACK，把cwnd设置为第一部中sstrsh的值，原因是该ACk确认了新的数据，说明重复ack时的数据都已经收到，恢复过程结束，可以恢复到之的状态，再次进入拥塞避免。

![image-20220424145009471](资料整理.assets/image-20220424145009471-16507830109983.png)

#### 问题解析

##### 什么时候SYN会被丢弃？

- 开启tcp_tw_recycle参数，并且在NAT环境下，造成SYN丢弃。

  > 开启tcp_tw_recycle可以快速回收处于TIME_WAIT的连接。使用前提是开启tcp_timestamps。
  >
  > 会丢弃的原因是：在NAT中，通过相同NAT网关的机器在服务端看来是相同的IP地址，服务器对IP地址检查而不是四元组所以无法区分，一旦先建立连接客户端A的时间戳大于后建立B的时间戳，那么会被认为是过期的数据包被丢弃。

- accept队列满了，造成SYN报文被丢弃。

##### 既然IP层会分片，为什么TCP层还需要MSS呢？

![image-20220423222431029](资料整理.assets/image-20220423222431029-16507238721461.png)

MTU：一个网络包的最大长度，以太网中一般为1500字节。 （IP数据包最大总长。）

MSS：除去IP和TCP头部后，一个网络包所能容纳TCP数据的最大长度。

当IP层有一个超过MTU大小的数据要发送，那么IP层就会分片，到目的主机再重新组装。但是一旦一个IP分片丢失，整个IP报文的所有分片都要重传，IP层本身没有超时重传机制，由传输层的TCP来负责超时和重传。当接收方发现TCP报文存在缺失，就不会发送ACK给发送方，发送方的TCP在超时后，会重新发送`整个TCP报文`。「由IP层进行分片传输，效率十分低下。」

##### SACK (Selective Acknowledgment)

SACK是一个TCP的选项，来允许TCP单独确认非连续的片段，用于告知真正丢失的包，只重传丢失的片段。要使用SACK，2个设备必须同时支持SACK才可以，包含**一系列的非连续的没有确认的数据的seq range**

##### 什么是SYN攻击，如何防范？

TCP建立连接需要三次握手，攻击者短时间内伪造不同的IP地址的SYN报文发送给服务器，服务器收到后进入SYN_RCVD状态，但是服务端发送出去的SYN+SYN报文，无法得到ACK应答。久而久之，就会占满服务端的未连接队列(SYN接收队列)，使得服务器不能为正常用户服务。

正常流程，存在两个队列：

- 服务端接收到客户端的SYN报文，会将其加入内核的SYN_RCVD队列。
- 服务端发送SYN+ACK给客户端，等待客户端回应ACK报文。
- 服务端接收到ACK报文后，从SYN_RCVD队列移除放入到Accept队列。
- 应用调用accept接口，从Accept队列取出连接。

解决方案：

- 修改内核参数，控制队列大小和队列满时应做操作。

  - 当网卡接收数据包的速度大于内核处理的速度，会有一个队列保存这些数据包。控制该队列的最大值参数为：net.core.netdev_max_backolg。
  - SYN_RCVD状态连接的最大个数。net.ipv4.tcp_max_syn_backlog
  - 超出处理能力时，对新的SYN直接回报文RST，丢弃连接。net.ipv4.tcp_abort_on_overflow

- net.ipv4.tcp_syncookies = 1。

  当SYN队列满之后，后续服务器收到SYN包，不进入SYN队列；服务器计算出一个cookie值，再以SYN+ACK中的序列号返回客户端；服务器收到客户端ACK时，会进行检查，合法就放入accept队列。

##### 如果已经建立了连接，客户端突然出现故障怎么办？

TCP具有保活机制，如果在定义时间段内，没有任何连接活动，TCP保活机制会每隔一段时间发送一个探测报文，连续几个探测报文都没有的到相应，则认为当前TCP连接已经死亡，上报给上层应用程序。

```cpp
net.ipv4.tcp_keepalive_time=7200  //保活时间 2小时 2小时内没有任何活动开启保活机制
net.ipv4.tcp_keepalive_intvl=75      //检测间隔75秒
net.ipv4.tcp_keepalive_probes=9    //表示检测9次无响应，认为不可达，从而中断。
```

需要注意：

- 对端程序正常时，保活探测报文收到响应，保活时间会被重置。
- 对端程序崩溃并重启后，TCP的保活探测报文是可以响应的，但是由于对端没有该报文信息，会发送一个RST报文，这样很快就可以发现TCP连接已经被重置。
- 对端程序崩溃，或其他原因不可达，连续探测无响应后，TCP会报告该TCP连接已死亡。

#### TCP缺点

- TCP升级困难：TCP协议是在内核实现的，因此要升级TCP需要升级内核，而内核升级比较麻烦、保守。而且TCP很多特性都是需要客户端和服务端同时支持才能生效的，而让所有客户端及时升级也是不现实的。

- 建立连接延迟：首先需要三次握手，另外现在大多使用的HTTPS，还需要TLS四次握手后，才可以实现数据传输，这在一定程序上增加数据传输的延迟。

  ![image-20220511093946203](资料整理.assets/image-20220511093946203-16522331894011.png)

  TCP三次握手的的延迟被TCP Fast Open(快速打开)这个特性解决了，这个特性可以在“第二次建立连接”时减少TCP连接建立的时延。

  <img src="资料整理.assets/image-20220511094315031.png" alt="image-20220511094315031" style="zoom: 50%;" />

  但是TCP Fast Open因为老式操作系统不支持的原因难以普及。而且TLS是在应用层实现的，TCP是在内核实现的，这两个过程无法结合。也因此，TLS对TCP报文无法加密。

- TCP存在队头阻塞：TCP是字节流协议，序列号较低的数据包丢失了，序列号较高的数据即使被接受了，应用层也无法读取。

- 网络迁移需要重新建立TCP连接：基于TCP传输的HTTP协议，通过四元组(源IP、源端口、目的IP、目的端口)确定一条TCP连接。例如移动端设备从4g切换为wifi时，ip地址改变了，需要重新建立TCP连接。

### UDP

#### UDP实现可靠传输：以QUIC为例

在UDP报文头部和HTTP消息之间，共有三层头部。

UDP Header -- Packet Header -- QUIC Frame Header -- HTTP3 Frame Header -- HTTP Message

- Packet Header
  - Long Packet Header用于首次建立连接。建立连接时也是需要三次握手，建立连接后以Destination Connection ID(连接ID)，从而实现连接迁移功能。
  - Short Packet Headery用于日常传输数据。短报头的每个报文是独一无二的编号，它是严格递增的(重传的报文编号比丢失要大)



### IP

将传输层报文作为数据部分，加上IP包头组装成IP报文。

## HTTP

### 常见问题，基本知识

定义：超文本传输协议，具体在计算机世界里在两点之间传输文字、图片、视频等超文本数据约定和规范。

#### HTTP状态码

1XX：协议处理的中间状态，还需后续操作。

2XX: 服务器成功处理了客服端请求。

- 200 OK：一切正常。
- 202 No Content：与200 OK基本相同，但是响应头没有body数据。
- 206 Partial Content：应用于断点续传或者分块，表示响应返回的body数据不是资源的全部。

3XX：表示客服请求资源发生了变动，需要用新的URL重新获取，也就是重定向。

- 301 Moved Permanently：永久重定向，请求资源已经不存在了，需要新的URL访问。

- 302 Found：临时重定向，资源还在但是需要另个一个URL访问。

  > 301、302都会在响应头使用Loaction，指明后续需要跳转的URL，浏览器会自动跳转。

- 304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户端，原来缓冲的文档还可以继续使用。

4XX：客户端发送的报文有误，服务器无法处理。

- 400 Bad Request：笼统表示客户端请求的报文有误。
- 403 Forbidden：服务器禁止访问资源，并不是客户端有错。
- 404 Not Found：请求的资源在服务器上不存在或未找到，无法提供给客户端。

5XX：客户端请求报文正确，但是服务器内部处理时出现了错误，属于服务器端的错误码。

- 500 Internal Server Error：同400，笼统表示服务器出现了错误。
- 501 Not Implemented：客户端请求的功能暂不支持。
- 502 Bad Gateway：服务器作为网关或代理时返回的错误码，服务器自身正常，访问后端服务器发生了错误。
- 503 Service Unavailable：服务器当前很忙，暂时无法响应。

#### HTTP字段 HTTP协议格式

![img](https://upload-images.jianshu.io/upload_images/1843940-d3214aa6ebf47292.png?imageMogr2/auto-orient/strip|imageView2/2/w/466/format/webp)

请求(响应)头、请求(响应)头部、空行，请求(响应)数据。



#### GET与POST

get、post、put(取代)、head、delete、trace。

GET是从服务器获取资源。

POST是向URI指定资源提交数据。

`URI统一资源标识符，URL统一资源定位符。URL是URI的子集，特指internet上描述信息资源的字符串。只要能唯一标识子资源的就是URI，在URI基础上给出期其资源访问方式的就是URL。URI类似接口抽象概念，URL是接口的具体实现。`

> GET与POST都是安全和幂等的吗？

- 安全：请求方法不会破坏服务器上的资源。
- 幂等：多次执行相同的操作，结果是相同的。

GET是安全且幂等的，POST是不安全且不是幂等的。

#### HTTP特性

- 简单：简单文本形式，HTTP基本报文格式是header+body，头部是key:value形式。
- 灵活和易于扩展：HTTP协议中的请求方法、URL/URI、状态码等组成要求没有被固定死，允许开发人员自定义和扩充。同时HTTP位于应用层，其下层可以随意
- 变化。HTTPS就是在HTTP和TCP之间加入了SSL/TLS安全传输层。
- 应用广泛和跨平台：无需安装APP，通过一个浏览器就可以在各种平台访问相同的资源。
- 双刃剑————无状态。好处：不需要额外信息记录状态，减轻了服务器压力。缺点：难以胜任关联性任务例如购物。解决方案：Cookie(客户端)，Session(服务端)。
- 双刃剑————明文传输。好处：方便阅读、调试。坏处：信息安全没有保障。
- 缺点：不安全。原因：
  - 明文传输，内容容易被窃听。
  - 不验证通信方身份，可能遭遇伪装。
  - 无法验证报文的完整性，内容可能被篡改。

### HTTP版本迭代

HTTP1.1

- 改进
  - 长连接。降低了通信和服务器开销。
  - 管道网络传输。同一个TCP连接中，客户端可以发起多个请求，不必等第一个回来再发起第二个请求。

- 瓶颈：
  - 头部未压缩，头部信息较多时延迟较大。头部冗长。
  - 队头阻塞，服务器按顺序响应请求。某个请求被阻塞时，后续所有请求也一同被阻塞。
  - 没有优先级控制。
  - 只能客户端发起。

HTTP2

- 改进
  - 头部压缩，同时发起多个请求的头部信息是相似或相同，会消除重读部分。HPACK算法，双方维护一张头部信息表，就只需要发送信息表索引号，提高速度。
  - 多路复用，可以在一个连接中并发多个请求或回应，无需按需一一对应。解决了队头阻塞。
  - 数据流(一组有序，有起点、重点的字节集和)发送而非按序(将当前所有需要发送的信息，作为一个数据流发送，其中可能包含了多个不同的请求)，每个数据流序号是唯一的，客户端数据流编号为奇数，服务器为偶数。
  - 可以指定优先级。
  - 服务器推送，服务器可以在浏览器请求HTML的时候，提前把可能用到的静态资源主动发送给客户端。
  - 二进制格式，对计算机友好，提高响应速度。

- 缺陷：
  - 多个HTTP复用一个TCP，TCP并不知道多少个HTTP，一旦丢包，所有HTTP请求必须等待这个丢包被重传。这是TCP的问题，所以在HTTP3中改为UDP。

HTTP3

- 改进
  - 使用基于UDP的QUIC协议，实现可靠型传输。QUIC在某个流丢包时，只会阻塞这个流，其他流不受影响。
  - TLS3使用最新1.3，头部压缩使用QPack。
  - QUIC把TCP和SSL/TLS六次合并为3次。

![image-20220421213539946](资料整理.assets/image-20220421213539946-16505481410578.png)

HTTP与HTTPS区别：

- HTTP明文传输存在安全风险，HTTPS在TCP和HTTP之间加入了SSL/TLS协议，使得报文得以加密传输。
- HTTP建立连接简单，HTTPS在HTTP三次握手之后还要进行SSL/TLS握手过程。
- HTTP端口80，HTTPS端口443。
- HTTP需要向CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的。
- `HTTP存在窃听风险、冒充风险、篡改风险。HTTPS混合信息加密解决窃听风险，身份证书解决冒充风险，校验机制摘要算法解决篡改风险。`
  - 混合加密：通信建立前使用非对称密钥交换会话密钥。通信时使用对称加密的会话密钥加密铭文数据。
  - 摘要算法：为数据生成独一无二的校验值，校验数据的完整性。
  - 数字证书：客户端借助CA获取可信的服务器公钥，加密信息发送给服务器，服务器使用私钥解密，能够正确解密建立连接的服务器就是可信的。

### HTTPS

#### HTTPs建立连接的过程

1、客户端发起https连接，DNS域名解析获取IP地址，绑定443号端口，发送请求，并携带自己支持的加密算法带给服务端；
2、 服务端发送证书。服务端收到这套加密算法的时候，和自己支持的加密算法进行对比（也就是和自己的私钥进行对比），如果不符合，就断开连接；如果符合，服务端就将SSL证书发送给客户端，此证书中包括了数字证书包含的内容：1、证书颁发机构；2、使用机构；3、公钥；4、有效期；5、签名算法；6、指纹算法；7、指纹。
3、客户端验证服务端发来的证书
验证证书；生成随机数；生成握手信息
4、服务端接收随机数加密的信息，并解密得到随机数，验证握手信息是否被篡改。
5、客户端验证服务端发送回来的握手信息，完成握手

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商产生会话密钥。
- 双方才采用会话密钥进行通信。

SSL/TLS协议建立详细流程：

- 客户端发起通信加密ClientHello请求，包含随机数、SSL/TLS版本号、密码套件(RSA)。

- 服务器收到请求后，响应ServerHello，包含确认SSL/TLS版本、随机数、确认密码套件、服务器数字证书。

- 客户端通过CA公钥验证数字证书，取出服务器公钥加密发送报文，包含随机数、改用会话密钥通知、客户端握手结束通知，之前所有数据做个摘要供服务端检验。 验证之前是否有被篡改过，下同。

- 服务器收到第三个随机数，通过协商的加密算法，计算出会话密钥。发送改用会话密钥通知、服务器握手阶段结束通知，以及之前所有数据摘要供客户端校验。(各自产生相同的通讯密码)

  SSL/TLS握手阶段结束，使用会话密钥加密的HTTP传输。

  > 公钥签发证书过程：CA将持有者的公钥、用途、颁发者等信息进行打包Hash计算；CA使用私钥对Hash加密，即进行了签名；将签名添加到到文件证书上形成数字证书。
  >
  > 客户端校验过程：使用同样Hash算法得到值H1；使用CA公钥解密得到H2；如果相等则为可信赖的。
  >
  > 使用RSA密钥协商，不支持前向保密，一旦服务端私钥泄漏，之前所有数据会被破解。
  >
  > DH每次密钥实时生成，实现前向保密，但计算效率低。现在大多使用ECDHE。

![img](https://upload-images.jianshu.io/upload_images/1843940-c29ede39ec5f6540.png?imageMogr2/auto-orient/strip|imageView2/2/w/362/format/webp)

#### HTTP(S)优化

##### HTTP优化

- 尽量避免发送HTTP请求。使用缓存，同时服务器会提供过期时间，保证数据是最新的。
- 减少请求次数。
  - 减少重定向次数。加入代理服务器完成重定向工作。代理服务器如果发现客户端请求的资源被重定向，代替客户端去完成重定向请求。记录重定向信息，下次可以直接获取。
  - 和并请求。多个访问小文件的请求合并为一个大请求，减少了头部消耗。为了防止队头阻塞，一般采用发起多个TCP连接，和并请求，减少TCP握手和慢启动消费的时间。
    - 合并多个小图片。
    - 讲图片二进制base64编码，以URL形式嵌入HTML文件
  - 延迟发送请求。用到再去获取。
- 减少服务器响应数据大小。资源压缩。
  - 无损压缩。信息不被破坏，完全可以恢复。用于文本文件、代码等。代码可以删除空格等。对原始资源进行统计，使用霍夫曼编码，常用资源使用较短二进制比特序列，不常用资源使用较长二进制比特序列表示。gzip常见，br效率更高。
  - 有损压缩。解压后数据跟原始数据不同但是比较接近。讲次要数据舍弃，保留主要特征，主要使用在多媒体数据。可以在请求头部的Accept的q质量因子，告诉服务器预期的资源质量。图片压缩常见PNG，webP效率更高。

##### HTTPS优化

- 硬件优化：选用支持加密特性的更强算力CPU。
- 软件优化：升级Linux、TLS版本。
- 协议优化：
  - 使用ECDHE，而不用RSA算法。ECDHE具有前向安全性，客户端可以在三次握手后发送加密数据，节省1RTT。
  - 将TLS升级为1.3，1.3握手只需1RTT，安全性更高。

- 证书优化
  - 选用ECDSA证书，而非RSA证书，因为密钥长度更短。
  - 服务器开启OCSOP，缓存证书验证结果。

- 会话复用，重连时直接使用上一次会话密钥，直接恢复。

  - Session ID(双方缓存唯一ID标识，与会话密钥时key-value关系)

  - Session Ticke(仅在客户端缓存，解决了负载均衡中下次提供的服务器可能没缓存的问题)

    虽然提高效率，但是存在重放攻击风险，不具备前向安全，需要设置合理过期时间。

## URL解析全过程

用户输入网址，浏览器发起DNS查询请求

建立TCP连接

浏览器向web服务器发送一个http请求

服务器发送响应数据给客户端

浏览器解析http response

## 问题整理

### ping整个过程

- 同一网段：封装二层报文，如果有目的主机MAC直接封装，没有的话通过ARP广播包获取。有了目的主机MAC地址封装到ICMP协议的二层报文发送，目的主机收到后会按照同样的格式返回一个报文。
- 不同网段：发现不是同一网段，就首先获取网关MAC，再发封装ICMP报文给网关路由器，目的主机收到收同上。

### DNS为什么使用UDP

避免使用TCP协议造成的连接时延，因为往往会向多个域名服务器查询，TCP会造成网页等待时间过长。

### 二层交换机和路由器区别

交换机在数据链路层，路由器在网络层。交换机通过mac地址来寻址，而路由器通过IP地址来寻址。

路由器接外网，交换机接内网。

交换机分割冲突域，但是不分割广播域。路由器分割冲突域和广播域。

> 广播域和冲突域区别：
>
> - 广播域可以跨网段，而冲突域是在同一个网段。
> - 冲突域是基于第一层，而广播域是基于第二层。
> - 广播域就是，站点发送一个广播信号，能接收到这个信号的范围。冲突域是一个站点向另一个站点发送信号，除目的站点，还能接收到这个信号的构成冲突域。

### TCP粘包 黏包 处理

概念：发送方发送的若干数据包达到接收方时粘成了一个包，从接收方缓冲区来看，后一包的数据头紧接着前一包数据的尾。

造成原因：

- 发送方：使用了Nalge算法(减少发送报文数量，合并多个小分组，在一个确认到达时一起发送)。
- 接收方：接收到的缓存速度大于读取速度，多个包会被缓存，就有可能读取到首尾连接到一起的包。

解决：

- 定长发送
- 尾部标记序列
- 头部标记分步接收(推荐)：定义一个用户报头，注明发送包的大小

# 操作系统

## 虚拟内存的定义以及实现方式

### 动机

传统存储管理方式的特征：各种内存管理策略都是为了同时将多个进程保存在内存种以便允许多道程序设计。具有以下共同特征。

- 一次性

  作业必须一次性装入内存，才可以开始运行。1）作业很大，一次不能全部装入时，该内存作业无法运行。2)大量作业需要运行时，内存不足以容纳所有作业，只能允许少量作业先运行。

- 驻留性

  作业装入内存后，就一直驻留，直至作业结束前，任何部分都不会被换出。而运行中的进程会因等待I/O而被阻塞，可能处于长期等待，而其他进程也无法使用这部分空间去运行。那么许多不用或暂时不用的程序占据了大量的内存空间，而一些需要运行作业又无法被装入，浪费了宝贵的内存空间。

### 局部性原理

- 时间局部性：如果程序中某条指令一旦执行，不久后该指令可能再次执行。数据访问也是如此。这是因为程序中存在大量的循环操作。

- 空间局部性：一旦访问了某个存储单元，不久后其附近的存储单元可能也将被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围之内。这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表的形式簇聚存储的。

  时间局部性是通常将近来使用的指令和数据保存在高速存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了"内存——外存"两级存储器的结构，利用局部性原理实现高速缓存。

### 虚拟存储器的定义和特征

基于局部性原理，在程序装入的时候，可以将程序的一部分装入内存，其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后执行程序。另一方面，操作系统将暂时不适用的内存换出到外存上，从而腾出空间存放将要调入内存的信息。这样好像为用户提供了一个大的多的存储器，称为虚拟存储器。

特征：

- 多次行：无需一次装入。
- 对唤醒：无需在作业运行时一直驻留。
- 虚拟性：从逻辑上扩充内存的容量，使用户看到的内存容量，远大于实际容量。

### 虚拟内存技术的实现

虚拟内存的实现要建立在离散内存管理方式的基础上。有以下三种方式：

- 请求分页存储管理。
- 请求分段存储管理。
- 请求段页式存储管理。

不管哪种都需要一定硬件的支持，如下：

- 一定的容量的内存和外存。
- 页表机制(或段页机制)，作为主要的数据结构。
- 中断机构，当用户要访问的部分尚未调入内存，则产生中断。
- 地址变换机构，逻辑地址到物理地址的变换。

#### 请求分页管理方式实现虚拟内存

将需要页装入内存就可以开始启动作业运行，发现所需页不在时再将其调入。同时，可通过置换功能将暂时不用的页面换出到外存上。

- 页表机制

  必然会出现放要访问页面不存在的情况，那么要解决缺页发现和处理问题。页表项由状态位P(是否在内存)，访问字段A(访问次数)，修改位M(是否被修改)，外存地址。

- 缺页中断

  缺页时产生中断，将缺页进程阻塞(调页完成唤醒)。如果内存还有空闲，直接存入，如果没有就淘汰某页(如果修改了，还要协会外存)。

- 地址变换机构

  ![img](资料整理.assets/70-16512415904784.png)

#### 页面分配策略：驻留集大小、调入页面的时机以及从何处调入页面

选择合适的驻留集：过小可以放更多进程，但是更容易缺页。过大，对缺页率影响不大，进程少。

三种策略：

- 固定分配局部置换：每个进程都一样，在运行期间不改变。
- 可变分配全局置换：每个按需分配，操作系统维持一个空闲物理队列，在某进程缺页时分配物理块。
- 可变分配局部置换：每个按需分配，在运行中频繁换页就增加物理块。如果缺页率特别低的，减少物理块。

调入时机：

- 预调入。依赖于优秀的预测。
- 请求调页。简单实现，一般虚拟存储器采用此策略。

何处调入：

分页系统外存分为两部分：用于存放文件的文件去和用于存放对换页面的对换区。对换区通常采用连续分配，而文件区采用离散分配方式。所以对换区I/O速度更快。

- 对换空间充足：全部调入对换。
- 对换空间不充足：调入可能修改部分。不会被修改的直接从文件区调入内存。
- UNIX方式：为运行过的页面，都从文件区调入。曾运行过又被换出的页面，从对换区调入。

#### 页面抖动(颠簸)和工作集

页面抖动：刚换出的内存又要换入，刚换入的内存要换出。主要原因是：进程高频刚问的页面数目高于可用的物理页帧数目。

工作集：某段时间间隔内，进程要访问的页面集合。经常使用的要保留在工作集中，不常使用的从工作集中丢弃。 工作集模型的原理：让操作系统跟踪每个进程的工作集，并为其分配大于其工作集的物理块。如果还有空间就可以再调进程到内存，如果工作机制和大于可用物理页的总数，就暂停一个进程，释放其页面给其他进程。

### 分页分段比较

|                |                             分页                             |                             分段                             |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      目的      | 页是信息的物理单位，分页是为了实现离散分配，以减少内存的外存的外零头，提高内存的利用率。其主要是满足系统管理的需要而不是用户的需要。 | 是信息的逻辑单位。含有一组其意义相对完整的信息。分段的目的是为了更好满足用户的需要。 |
|      长度      | 页的大小固定且由系统决定。由系统把逻辑地址划分为页号和页内地址两部分，由机器硬件决定，因而在系统中只能有一种大小的页面。 | 段的长度不固定，决定于用户所编写的程序。通常由编译程序在对流程序进行编译时，根据信息的性质来划分。 |
|    地址空间    | 作业空间地址是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，就可以表示一个地址。 | 作业空间是二维的，程序在标识一个地址时，即需给出段名，又需给出段内地址。 |
|      碎片      | 有内部碎片 无外部碎片<br />内部碎片是指已经被分配出去的内存大于请求所需的内存空间。 | 由外部碎片 无内部碎片<br />外部碎片是指还没有分配出去，但由于太小而无法分配给申请空间的新进程的内存空间空闲块。 |
| 共享和动态链接 |                          不容易实现                          |                           容易实现                           |

分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“**页内碎片**”。页表的作用是实现从页号到物理块号的地址映射。

分段存储管理方式的目的，主要是为了满足用户（程序员）在编程和使用上多方面的要求。

段页式存储管理方式

前面所介绍的分页和分段存储管理方式都各有优缺点。分页系统能有效地提高内存利用率，而分段系统则能很好地满足用户需求。我们希望能够把两者的优点结合，于是出现了段页式存储管理方式。

段页式系统的基本原理，是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，地址结构由段号、段内页号和页内地址三部分所组成。同样需要增设联想寄存器。

## 系统磁盘分配

硬盘读写的基本单位：扇区。

系统分配磁盘空间的基本单位：簇

# 数据结构

## 数据的逻辑结构

- 集合：除了“同属于一个集合”外，不存在其他关系。
- 线性结构：结构中数据和元素位置之前存在一对一的关系。
- 树形结构：结构中的元素值间存在一对多的关系。 
- 图形结构：数据中的元素存在多对多的关系。又称网状结构。

## 栈

概念：只允许在有序的线性数据集合的一段(成为栈顶top)，进行加入数据(push)和移除数据(pop)，后进先出。

用数组实现的栈叫顺序栈，用链表实现的栈叫链式栈。

## 队列

先进先出的线性表。通过用数组或链表实现。队列只允许在后端插入(入队)，前端删除(出队)。

分类：

- 单队列
- 循环队列：解决了顺序队列(数组是实现的队列)的假溢出和越界问题。



## 图

图是一种非线性结构。概念：由有穷非空集合的顶点和顶点之间的边组成。

图的存储：邻接矩阵。邻接表存储(链表)。

图的搜索：广度优先(队列实现)、深度优先(栈实现)

## 树

高度：该节点到叶子节点最长路径包含的边数。根节点高度最高。

深度：根节点到该节点所包含的边数。

满二叉树：一个二叉树，每一层的节点数都达到了最大值。如果层数为k，那么总节点数就是2^k^-1

完全二叉树：除最后一层外，其余层都是满的。中间节点不存在null。若父节点序号为i，左节点为2*i,右节点为2*i+1。

### 二叉排序树

定义：左边比根节点小，右边比根节点大，并且左右子树都是二叉排序树。

缺点：插入是有序的就会退化为链表。

解决：平衡树 如红黑树。保证平衡的原因是树的查找性能由树高决定，让树尽可能平衡就是为了降低树的高度。 

### AVL树——平衡二叉树

定义：二叉排序树的基础上，AVL树任意节点的左、右子树的高度差最大为1。

查找复杂度为O(logn)。

### B树——平衡多路查找树

定义：和AVL树不同的是B树属于多叉树。 

目的：节点可以有多个孩子节点(可2个以上)进一步降低树的高度，无限多路会退化成有序数组。

特点：

- 每个结点的值(索引)都是按递增次序排列存放的，并遵循左小右大原则。
- 根节点的子节点个数为[2, M]。
- 除根节点以外的非叶子节点的子结点个数为[ceil(M/2), M]。ceil()为向上取整。
- 每个非叶子节点的值(索引)个数=子节点个数-1。最小值为ceil(M/2) - 1，最大为M-1个。(插入时超出M-1从中间分裂，小于最小值时先借值，不够再合并)
- B树的所有叶子节点都位于同一层。
- 叶子节点或非叶子节点值超过m-1，从中间分裂，网上递归，引起父节点数量超过继续分裂。

好处：

- 在数据库查询中，以树存储数据。树有多少层，就读多少次磁盘IO。（B树高度低，IO少，提高查询效率）
- B树的每一个节点都包含key(索引值)和value(对应数据)，因此访问里根节点近的树会更快速。(相比B+树)



### [B+树](http://t.csdn.cn/BqL3D)

hash比B+树查询速度快，为什么用B+树存索引？

​	和业务场景有关，只选一个数据确实hash更快，但是数据库中经常选择多条，这时候由于B+树索引有序，并且有链表相连，查询效率就比hash快很多了。

数据库中的索引一般在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计允许数据分批，同时树的高度较低，提高查找效率。

**和B树不同的是**

- B+树内部有两种节点，一种是索引节点，一种是叶子节点。
- B+树的索引节点并不会保存记录，只用于索引，所有的数据都保存在B+树的叶子节点中。而B树是所有节点都会保存数据。
- B+树所有的叶子节点都会被连城一条链表，叶子本身按索引值从小到大进行排序。
- B树的所有索引值是不会重复的，而B+树非叶子节点的索引值最终一定会出现在叶子节点中。

有了B树为什么要有B+树，B树好处：B树每个一个节点都包含Key和value，因此访问离根节点近的元素会更快速。B树的不足：不利于范围查找。

### 各类树应用场景

AVL树 windows进程地址空间的管理

红黑树 map set epoll

b/b+树 磁盘文件组织、数据索引和数据库索引

Trie树(字典树)：统计和排序大量字符串。

### 平衡二叉树

可以是空树

如果不是空树，那么左右子树的高度差不超过1，并且左右子树都是一颗平衡二叉树。



## **B树和B+树的区别**

B/B+树用在磁盘文件组织、数据索引和数据库索引中。其中B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引，因为：
**1、B+树的磁盘读写代价更低**
B+树的内部结点并没有指向关键字具体信息的指针。因此其**内部结点**相对B 树**更小**。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

\> 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

**2、B+-tree的查询效率更加稳定**
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的**路径长度相同**，导致每一个数据的查询效率相当。

3、**B树在元素遍历的时候效率较低**
B+树只要遍历叶子节点就可以实现整棵树的遍历。在数据库中基于范围的查询相对频繁，所以此时B+树优于B树。

#### AVL平衡二叉树

##### 二叉搜索树定义：

若它左子树不为空，则它左子树上所有节点值小于根节点，若右子树不为空，则它右子树上所有节点值大于根节点，它左右子树也是二叉搜索树。

定义:在二叉搜索树的基础上要求，任何两棵子树的最大高度差为1. 查找、删除和插入在平均和最坏的情况下的时间复杂度都是O(log~n~)。

动机：二叉搜索树可以提高搜索效率，但是在高度严重失衡的时候，搜索效率最差降为O(n);

插入新节点时，平衡二叉树可能失衡，通过旋转最小失衡子树来完成失衡调整。

最小失衡子树：在先插入的节点向上查找，以第一个平衡因子的绝对值超过1的节点为根的子树乘醉最小失衡子树。调整方式，左旋、右旋。

具体方式：将最小失衡子树深度较大的子树一侧的子节点作为当前父节点，子节点的对应被替代的子树作为当前节点的子节点。

![img](资料整理.assets/v2-db1cdb0da952a71f9b6d64b2608467eb_b.gif)

#### [插入节点四种情况](https://zhuanlan.zhihu.com/p/56066942)

- LL(在左孩子的左子树插入节点)，右旋一次。
- RR 左旋一次。
- LR 左旋再右旋。更改后的根节点为左孩子的右孩子。
- RL 右旋再左旋。更改后的根节点为右孩子的左孩子。

以LR为例：

A的左孩子节点B的右子树插入节点F，导致节点A失衡。

![image-20220510230403991](资料整理.assets/image-20220510230403991-16521950466951.png)

![image-20220510230450222](资料整理.assets/image-20220510230450222-16521950934712.png)

![image-20220510230601189](资料整理.assets/image-20220510230601189.png)

#### 红黑树

特点：

- 每个节点非红即黑。

- 根节点总是黑色的。

- 每个叶子节点都是黑色的空节点(NIL节点)。

- 如果节点是红色，则他的子节点必须是黑色的(反之不一定)。

- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。

以上规则保证了自平衡，以及从根节点到叶子节点的最长路径不会超过最短路径的2倍。

新插入的为红色节点。

调整方法：

- 变色

- 旋转

  - 左旋

    逆时针旋转红黑树的两个节点，是的父节点被自己右孩子取代，自己成为原本位置的左孩子。

    ![image-20220510231502669](资料整理.assets/image-20220510231502669-16521957049163.png)

  - 右旋

红黑树插入节点的五种不同的局面：

- 新节点位于树根，没有父节点。

  直接让节点变为黑色。满足了规则2，也没有打破规则5。

- 新节点B的父节点是黑色的。  没有打破红黑树的规则，所以不需要调整。

- 新节点D的父节点和叔叔节点都是红色的。

  ![image-20220510232007953](资料整理.assets/image-20220510232007953-16521960092515.png)

  先让节点B变为黑色，这样B所在路径凭空多出一个黑色节点，打破了规则5，因此让节点A变为红色，这样AC都为红色，不符合4，5。此时再让C变为黑色，就完成了调整。

- 新节点D的父节点是红色，叔叔节点是黑色或者没有叔叔，且新节点是父节点的右孩子，父节点B是祖父节点的左孩子。

  ![image-20220510232331617](资料整理.assets/image-20220510232331617-16521962133356.png)

  以节点B为轴，做一次做左旋转，使得D成为父节点，B成为D的左孩子。进入局面5.

- 新节点D的父节点是红色，叔叔节点是黑色或者没有叔叔，且新节点是父节点的左孩子，父节点B是祖父节点的左孩子。

  ![image-20220510232559051](资料整理.assets/image-20220510232559051-16521963600597.png)

  以节点A为轴，做一次右旋转，是节点B成为祖父节点，A成为B的右孩子。

  让节点B变为黑色，节点A变为红色。(此时，B右子树到根节点两个黑色，左子树一个黑色，看似违反了规则5，但是每个三角代表的为子树，子树会补齐黑色节点)。

  <img src="资料整理.assets/image-20220510232739174.png" alt="image-20220510232739174" style="zoom:50%;float:left" /><img src="资料整理.assets/image-20220510233116569.png" alt="image-20220510233116569" style="zoom:50%;" />

  如果局面4的中的父节点是B的右孩子，则成为了局面5的镜像，原本右旋变为左旋。

  如果局面5中的父节点B是右孩子，则成为了局面4的镜像，原本左旋操作改为右旋。

# 计算机基础知识

## UML类图

### 基础属性

> -表示private
>
> +表示protect
>
> ~表示defalut,即包权限
>
> _下划线表示static(eg: <u>+age:int</u>)
>
> 斜体表示抽象

![image-20220410185505440](资料整理.assets/image-20220410185505440-16495881093371.png)

三层分别是类名, 变量, 函数.

### 类之间的关系

- 泛化(Generalization)

  定义: 是一种继承关系,指定了子类如何特化父类的所有特征和行为.

  图标:带三角箭头的实线,箭头指向父类.

- 实现(Realization)

  定义: 是一种类与接口的关系,表示类是接口所有特征和行为的实现.

  图标: 带三角箭头的虚线,箭头指向接口.

- 关联(Association)

  定义: 是一种拥有关系,它使一个类知道另一个类的属性和方法.如老师与学生.关联可以是双向的,也可以是单向的.双向的关联可以有两个箭头或者没有箭头,单向的关联只有一个箭头.

  图标: 带普通箭头的实心线,指向被拥有者.

  代码体现: 成员变量.

- 聚合(Aggregation)

  定义: 是整体与部分的关系.弱的"拥有关系",即has-a的关系,体现的是A的对象可以包含B的对象,而B的对象不是A的对象的一部分,两个对象具有各自的生命周期.关联和聚合在语法上无法区分,只有在逻辑中体现.聚合**强调组织与个体**.

  图标: 带空心菱形的实心线,菱形指向整体,普通箭头指向部分.

  代码体现: 成员变量.

- 组合(Composition)

  定义: 是整体与部分的关系.是强的"拥有关系",是一种contains-a的关系,体现了严格的部分与整体的关系,是比聚合还要强的一种关联关系.它要求普通的聚合关系种代表整体的对象负责代表部分的对象的生命周期.组合强调身体与器官(或四肢).

  代码体现: 成员变量

  图标: 带实心菱形的实现,菱形指向整体,普通箭头指向部分.

- 依赖(Dependence)

  定义: 是一种使用关系,所以尽量不要使用双向的依赖.

  图标: 带箭头的虚线,指向被使用者.

  代码体现: 局部变量,方法的参数或者对静态函数的调用.

![image-20220410202806705](资料整理.assets/image-20220410202806705-16495936896663.png)

企鹅需要了解气候变换,所以是一种关联关系,气候被企鹅所了解.

重数表示方式

|  0..1   | 另一个类的一个对象与该类没有关系,或至于一个该类对象有关系 |
| :-----: | :-------------------------------------------------------: |
| 1..1或1 |         另一个类的一个对象只与一个该类对象有关系          |
|  0..*   |       另一个类的一个对象与零个或多个该类对象有关系        |
|  1..*   |       另一个类的一个对象与一个或多个该类对象有关系        |
|  m..n   |   另一个类的一个对象与至少m个最多n个该对象有关系(m<=n)    |

# LINUX开发

## 零、LINUX基础知识

### 用户态、内核态

用户态：应用程序只能在用户态运行。——非特权指令(不能对系统软硬解直接访问，访问受限)——CPU可被抢占

内核态：操作系统在内核态运行。——特权指令(访问空间不受限制)——CPU不可被抢占

划分用户态、内核态作用：为了保证系统程序不被应用程序有意无意的破坏。需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络。从硬盘读取数据，获取输入必须经过内核态。

- **用户态**切换到**内核态**的**唯一**途径——>**外围设备中断/异常/陷入**(系统调用，本质开了一个中断)
- **内核态**切换到**用户态**的途径——>设置程序状态字

当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

内核，它是一种**特殊的软件程序**，——**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

### C/S、B/S

C/S通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端硬件环境的优势。安全性高。一般局域网。客户端将负担分配到每个用户，从而可以节约服务器资源。

B/S 利用WWW浏览器技术节约了开发成本和使用成本。一般广域网。服务端统一处理有更好的安全性和稳定性而且升级比较容易，不过服务器负担就增加了。

### [LINUX常用命令](http://t.csdn.cn/rTAI7)

- 关机 shutdown

- 文件查看 ls -l r t  文件操作 rm  mv  rename   cp  file 

- 空间查看  du 

- tar zip 压缩

- 硬件及系统信息

  - uname -r 内核版本
  - lscpu
  - cat /proc/meminfo  查看内存信息

- 文本查看  cat 

- 文件查找 find      find . -type f -name '*.py'|xargs grep -n ' '

- 查看以来的库  objdump -x xxx.so | grep NEEDED  

- readelf  和objdump命令提供的功能类似，但是它显示的信息更为具体

- ldd   打印库文件或程序所依赖的共享库列表。

- 测试磁盘读写速率 hdparm -t /dev/sda

- 查看磁盘分区信息  sudo fdisk -l

- top   查看内存  CPU使用率

- 文本搜索 grep

- 路径切换 cd

- lsof 一切皆文件  查看进程、 文件相关进程、某个程序进程所打开的文件信息  lsof -i 列出所有网络连接

- iostat\[参数]\[时间][次数]  方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息

- nm 查看符号表

- 基本shell命令

- mkdir创建目录

- ln硬连接与软连接

- 改变进程优先级 renice  -n N -u/-g/-p xxx   N代表优先级(0最高)  -u 用户  -g 组  -p  pid 进程号   

- 查看进程ps aux 所有进程 
  - PS命令，该命令可以查看哪些进程正在运行及其运行状态；

  - Top命令，该命令可以实时显示各个线程情况；

  - Pstree命令，该命令以树状图的方式展现进程之间的派生关系；

  - Pgrep命令，以名称为依据从运行进程队列中查找进程，并显示查找到的进程id。

- 查看端口占用情况
  - lsof -i:端口号

  - netstat -tunlp

    - -t (tcp) 仅显示tcp相关选项

    - -u (udp)仅显示udp相关选项

    - -n 拒绝显示别名，能显示数字的全部转化为数字

    - -l 仅列出在Listen(监听)的服务状态

    - -p 显示建立相关链接的程序名
- 创建文件
  - touch  适合创建一个空文件  ()  touch 已存在文件 会更新时间为当前 不改变内容
  - \> 重定向符号 可以将原本输出到终端的信息 输出到文本中  >覆盖  >> 追加
  - echo 显示文本到终端，可以通过重定向到文件中，  echo可以 -e 按照字符处理  可以控制输出 字符串背景不同颜色 通过打印变量 写入时间 echo \`date`
  - vi vim  创建打开文本编辑
  - cp  拷贝出新文件
  - cat  >> test.txt << eof  最后输入eof回车 会结束输入  cat可以在终端命令行页面直接输入。



### I/O全过程 从网卡到应用

网卡：将光信号、电信号还原为数字信息，DMA方式写到缓存。网卡通过中断将数据包到达的事件通知给CPU，CPU开始用网卡驱动工作：从网卡缓存去接收数据，根据MAC头部以太类型字段判断协议并调用对应处理软件。一般是TCP/IP协议栈，以此为例：

- 网卡驱动程序提取帧全部内容，去掉以太网帧头，向上传递给IP层。
- IP层收到包，去掉IP头的内容，交给TCP层。
- TCP层根据TCP协议定义格式，继续解包，read()从socket buffer读取数据，传递给应用层。
- 应用层根据TCP层传来的数据，进行分析。 

I/O操作流程：1.调用系统IO函数。2.系统等待数据就绪。3.将IO数据由系统内存拷贝到用户内存空间中。4.用户程序操作IO函数调用返回的数据。

### socket通信

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。

[scoket本机进程之间通信](http://t.csdn.cn/WFgN9)

## 一、Linux编程入门

### 静态库和动态库的制作使用

#### 静态库

命名：libxxx.a

制作过程：1. gcc获得.o文件    

​		 2.使用ar工具(archive)讲.o文件打包   ar rcs libxxx.a xxx.o xxx.o   

​                                         (r 将文件插入备存文件中 c简历备存文件 s索引)

#### 动态库

命名：libxxx.so
		制作过程：1.gcc得到.o文件，和位置无关的代码   gcc -c -fpic a.c b.c

​            		2.gcc得到动态库   gcc -shared a.o b.o -o libxxx.so

#### 对比：

静态库： GCC 进行链接时，会把静态库中代码打包到可执行程序中。
		动态库： GCC 进行链接时，动态库的代码不会被打包到可执行程序中。

静态库的优缺点：

优点：静态库被打包到应用程序中加载速度快，发布程序无需提供静态库，移植方便程序
		缺点：消耗系统资源，浪费内存更新、部署、发布麻烦

动态库的优缺点

优点：可以实现进程间资源共享（共享库）更新、部署、发布简单，可以控制何时加载动态库

缺点：加载速度比静态库慢，发布程序时需要提供依赖的动态库

## 二、多进程开发

### 临界区

定义：访问共用资源的代码段，而这个共用资源无法同时被多个线程/进程访问。

调度原则：

- 若干进程要求进入临界区，一次仅允许一个进程进入。
- 任何时候，处于临界区的进程不可多于一个。
- 进入临界区的进程要在有限时间内退出。
- 如果进程不能进入临界区，则应该让出CPU，避免忙等的情况。

### 进程状态转换

进程状态：就绪、执行、阻塞。  阻塞不能直接变为执行。

就绪态是进程已经取得了除CPU外所有其他资源。

进程上下文切换包含的信息：

- 寄存器：通用目的寄存器、浮点寄存器、程序计数器、状态寄存器
- 用户栈
- 内核栈
- 各种内核数据结构(描绘地址空间的页表，进程表，文件信息表等)

### 进程的调度

- 先来先服务(FCFS)
- 短进程优先
- 高优先权优先调度
- 基于时间片的轮转调度算法
- 多级反馈队列调度算法：综合时间片轮转算法和优先级算法的综合和发展。

### 孤儿进程、僵尸进程、进程回收

孤儿进程：父进程运行结束，但是子进程还在运行。每当出现孤儿进程的时候，内核会把孤儿进程的父进程设为init(pid 1)，而init会循环wait()已退出的子进程，完成对子进程的回收，因此孤儿进程不会有什么危害。

僵尸进程：每个进程接收后，都会释放自己地址空间中的用户区数据，内核区的PCB没办法自己释放掉，需要父进程释放。而子进程接受后，父进程没有回收资源，就成为了僵尸进程，僵尸进程不能被kill -9杀死。如果产生大量僵尸进程将会导致系统不能产生新的进程，因此危害较大，应当避免。

进程回收：父进程可以调用wait(阻塞)、waitpid(非阻塞,并且可以指定等待那个子进程结束)。一次调用只能清理一个子进程。

### fork()子进程与共享资源

Linux每个进程都有4G的虚拟地址空间(独立的3G用户空间和1G内核空间)。

子进程是父进程的副本，继承了数据段、代码段、栈段、堆，系统进行了优化，这些数据没有被修前，父子进程共享一份，修改后，会真正复制创建。写时拷贝。 不同是的父子进程的ID

### 进程间通信方式

#### 管道

##### 匿名管道

半双工通信，只能在具有亲缘关系的进程间使用(因为创建子进程，会拷贝父完全进程数据，父子进程同时各有两个fd对应管道的读端、写端)。

优点：简单方便。		缺点：单向通信，只能在有亲缘关系的进程之间，缓冲区有限。

本质是一个伪文件(实为内核缓冲区)，由两个文件描述符引用，一个表示读端，一个表示写端。

int pipe(int pipefd[2]) 0成功  pipefd[0] 为读 pipefd[1]为写

##### 有名管道

半双工通信，允许无亲缘关系进程间的通信。

优点：可以实现任意关系的进程间的通信。		缺点：长期存在于系统中，使用不当容易出错。缓冲区有限。

实质上也存在内存缓冲区。

int mkfifo(const char* path, mode_t mode);   \$1 为路径名 创建后FIFO名字， $2 为文件读写权限  如0666 为 rw-rw-rw-

#### 信号量

一个计数器，可以用来控制多个线程对共享资源的访问。

优点：可以同步进程。   缺点：信号量有限，表达信息量有限。

#### 信号

一种较为复杂的通信方式，用于通知接收某个事件已经发生。

向进程发送信号的3种方法：1.使用kill。 2.从另一个进程向一个进程发送信号。 3. 从键盘向进程发送信号。

#### 消息队列

是消息的链表，放在内核中，并由消息队列标识符标识。

优点：可以实现任意进程间的通信，并通过系统调用来实现消息发送与接收间的同步，使用方便。

缺点：信息的复制需要额外消耗CPU事件，不适合信息量大或操作频繁的场景。

#### 共享内存

优点：无需复制，快捷，信息量大。

缺点：通信是通过共享空间直接附加到虚拟地址空间中实现的，因此要注意读写同步问题。利用内存缓冲区交换信息，所以只能同一个计算机系统中诸多进程共享，不可网络通信。

共享内存需要注意的地方：

- 共享内存注意是否超过大小限制，
- 共享内存多次shmat(shmid, null, 0), 不能及时释放，一直消耗进程得虚拟空间。
- 多个进程使用同一个共享内存id，进行多次共享挂载，前后申请大小不一致会造成数据丢失。
- 对共享内存删除后，再进行操作会失败。

#### 套接字

优点：可用于不同计算机间的通信。传输数据为字节级，传输数据可自定义，数据量小，效率高。传输数据时间短，性能高。适用于客户端、服务器端之间信息实时交互。可以加密数据，数据安全性强。

缺点：需要对数据解析，转为应用级数据。

### 进程内存空间组成

![image-20220331093228798](资料整理.assets/image-20220331093228798-16486903608851.png)

#### 进程间私有和共享的资源

私有：地址空间、堆、全局变量区、栈、寄存器。

共享：代码段、公共数据、进程目录等。

### 守护进程

概念：常说的Daemon进程(精灵进程)，是Linux中的后台服务进程，生存周期较长，独立于控制终端并周期性的执行某种任务或者等待处理某些发生的事件。

创建步骤：

- 执行一个fork(),之后子进程退出，子进程继续执行。

  在shell终端里造成一个程序已经运行完毕的假象，之后所有工作在子进程中完成，而用户可以在shell终端里可以执行其他命令，在形式上实现了与控制终端分离。

- 子进程调用setsid()开启一个新会话。

  创建子进程时，fork()了父进程的会话组、进程组、控制终端资源，因此虽然父进程退出了，但是这些资源没有改变，因此需要setsid()来让子进程完全独立出来。前提是该进程不能是进程组组长，因此需要先fork并且杀死父进程。会话对终端独占性，子进程同时与控制终端脱离。

- 再次fork()创建一个子进程。现在父进程已经成为无终端进程，但是可以申请重新打开。可以通过使进程不会在成为会话组长来禁止进程重新打开控制终端。

- 清除进程的umask(设为0)以确保当守护进程创建文件和目录时拥有所需的权限。

- 修改进程的当前工作目录，通常会改为根目录(/)。

  进程在运行中，当前目录所在的文件系统是不能卸载的，这对使用会造成很多麻烦。

- 关闭守护进程从其父进程那里继承而来的所有打开者的文件描述符。

- 再关闭了文件描述符0，1，2之后，守护进程通常会打开/dev/null，并使用dup2()使所有文件描述符指向这个设备。

- 核心业务逻辑。

守护进程是个特殊的孤儿进程，脱离终端。原因是避免被终端产生的任何信息所打断，也不再终端显示任何信息。

### 协程

协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

子程序其实是协程的特例

协程的特点在于是一个线程执行。极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；

不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多

在协程中控制共享资源不加锁，但是协程内部操作共享资源还是要加锁

### [惊群效应](https://blog.csdn.net/lyztyycode/article/details/78648798)

定义：多进程(线程)在同时阻塞等待同一个事件的时候(休眠状态)，如果等待的这个事件发生，它就会唤醒所有对应等待进程，但是最终只有一个进程获得这个事件的控制权，其他进程获取失败，重新进入休眠状态，造成性能浪费。

消耗了什么：系统对用户进程/线程频繁的做无效的调度，上下文切换系统性能大打折扣。 为了保证一个线程获得资源，还要加锁。

## 三、多线程

### 内核线程、用户线程区别

用户线程：不需要内核支持而在用户程序中实现的线程，利用库函数完成线程创建、同步、调度和管理，不需要用户态、内核态切换，速度较快。

优点：

- 不需要内核参与，比较简单，在操作系统不支持线程中也可以实现。
- 创建、切换护和销毁代价也比内核线程小的多。
- 允许每个进程定制自己的调度算法，比较灵活。
- 线程可以利用的表空间和堆空间比内核级线程多。

缺点：同一进程只有一个线程可以运行，当一个线程被阻塞，整个进程都会被挂起。

系统线程：由内核系统创建和撤销。内核维护进程及线程的上下文信息及线程切换，一个内核线程由于IO操作而阻塞，不会影响其他线程的运行。

实际应用中，当从用户态代码切换到系统代码会涉及上下文切换，需要一定的代价，而且频繁创建系统线程代价十分大。用户态抽象多个执行单位，把用户态线程映射到少量的系统线程上去，内核态负责执行，用户态线程负责存储状态（栈、寄存器等上下文信息），绑定到一个系统线程，系统线程执行完之后只需要把这个状态杀掉，不需要消灭着这个系统线程。

### 进程、线程、协程区别

**进程**：系统进行资源分配和调度的一个独立单位。 

**线程：**是进程的一个执行单元，是进程内可调度实体。处理器调度的基本单位。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。进程有自己独立的地址空间，建立数据表来维护代码段、堆栈段和数据段。

**区别：**

- ​	进程内的多个线程共享堆和方法区资源，线程独有的是运行中必不可少的资源程序计数器、栈、一组寄存器。最主要差别是不同的系统资源管理方式，进程之间资源是独立，一个进程崩溃后在保护模式下不会对其他进程产生影响。而线程没有独立的地址空间，一个进程内一个线程崩溃会造成整个进程崩溃。多进程更**健壮**，而多线程切换时资源消耗较小。每个独立的线程有一个程序入口、执行序列和出口。但是线程不能独立执行，要以依托在应用程序中。
- 通信机制，线程共享数据段所以通信(全局变量、静态变量等)很方便。进程间相对复杂如：管道、信号、消息队列、共享内存、套接字等。

**关系：**一个线程可以创建和撤销另一个线程，同一个进程中的线程可以并发执行。相比进程，线程更接执行体的概念。一个进程至少有一个线程。

协程：是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。

进程和线程的根本区别在于隔离性，互不信任的多个任务应当放到多个进程中实现强隔离。

地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。

资源：线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。

健壮性：多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。

执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。

但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。

切换时：进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。



**协程和线程的区别**

协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多CPU的能力。

**线程**

相对独立

有自己的上下文

切换受系统控制；

**协程**

相对独立

有自己的上下文

切换由自己控制，由当前协程切换到其他协程由当前协程来控制。



**何时使用多进程，何时使用多线程？**

对资源的管理和保护要求高，不限制开销和效率时，使用多进程。

要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。

#### 线程之间私有和共享的资源：

私有：线程栈、寄存器、程序计数器

共享：堆、地址空间，全局变量，静态变量。

#### 进程抢占

1. 更高优先级进程进入。2。 当前进程时间片到期。



### 线程同步 线程通信方式

#### [锁](http://t.csdn.cn/BY4QC)

##### 死锁

**概念：** 多个并发进程因争夺系统资源而产生相互等待的现象。

死锁产生的4个必要条件
    1、互斥： 某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
    2、占有且等待： 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
    3、不可抢占： 别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
    4、循环等待： 存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。
 产生死锁需要四个条件，那么，只要这四个条件中至少有一个条件得不到满足，就不可能发生死锁了。由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以，主要是破坏产生死锁的其他三个条件。
a、破坏“占有且等待”条件
     方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。
         优点：简单易实施且安全。
         缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。
                  使进程经常发生饥饿现象。
     方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。
b、破坏“不可抢占”条件
      当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。
      该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。
c、破坏“循环等待”条件
     可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。如图所示：

死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。

常用的解除死锁的方法：
1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。
2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。
     a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。
     b、逐个终止进程，直至死锁状态解除。

两种避免办法：
    1、如果一个进程的请求会导致死锁，则不启动该进程
    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。
避免死锁的具体实现通常利用银行家算法

###### 银行家算法

四种数据结构：

- 可利用资源向量Available。m个元素的数组，每个元素代表对应类可用资源数组。
- 最大需求矩阵Max。每个进程实现表明对m个资源分别最大需求数量。
- 分配矩阵Allocation。表示每一类资源当前已经分配给每一进程的数量。
- 需求矩阵Need。用以表示每个进程对每个资源还需要的数量。

其中存在关系： Need[i, j] = Max[i, j] - Allocation[i, j]

算法简述：

​	设Request[j] = k是进程Pi的请求向量，表示进程Pi需要K个Rj类型的资源。当Pi发出请求后，系统按照一下步骤进行检查：

1. 若Request[j] ≤ Need[j] 继续下一步。否则，认为出错，因为它所要申请的资源已经超过它所宣布的最大值。
2. 若Request[j] ≤ Available[j], 继续下一步。 否则，申请资源数量超出可用，Pi需等待。
3. 系统尝试把资源分给Pi, 并修改下面数据结构中的值。
   - Available[j] = Available[j] - Request[j]
   - Allocation[i, j] += Request[j]
   - Need[i, j] -= Request[j]
4. 系统执行安全性检查，若安全才正式分配给Pi，以完成本次分配。否则分配失败，恢复原本资源分配状态，Pi等待。



安全性算法：

1. 设置工作向量work，表示可提给进程各资源的数目，开始时 work = Available；设置Finsh，表示是否有足够资源分配给进程，初始值为false，检查后有资源分配给进程Finsh[i] = true。

2. 从进程集合中找到一个满足以下条件的进程：

   - Finsh[i] = flase 	&&		Need[i, j] ≤ Work[j]

   若找到执行3， 否则执行4。

3. 当进程Pi获得资源后，可顺利执行，直至完成，并释放出所申请的资源。故应执行：

   - work[j] += Allocation[j]		 &&		Finsh[j]  = true    转到步骤2，继续执行。

4. 如果所有进程都满足 Finsh[i] = true, 则表示系统处于安全状态，否则就是处于不安全状态。

**注意：**执行完一轮后，存在false进程，需要重新从头检查，是否已经可以安全执行。只要false 在 tru就需要再次检查true进程执行后释放的资源是否可以让之前false进程安全执行。

[银行家算法例题](http://t.csdn.cn/7N8uN)

[银行家算法-讲解-源码](http://t.csdn.cn/uOp6k)

##### 互斥锁

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；

加锁失败会有两次上下文切换的成本。

```cpp
//std::lock_guard的使用 
std::mutex _mutex;
std::lock_guard<std::mutex> lock(_mutex); //出了作用域会自动释放
```

##### 自旋锁

- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

自旋锁效率高于互斥锁(锁住代码的执行时间)但是如果不能在短时间内获得锁，会降低CPU效率，因此要慎重，在内核可抢占的或SMP(对称多处理，几个CPU核心对于内存来讲地位是相同的)情况下使用。

##### 悲观锁

总是假设最坏的情况，每次拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿数据，就会阻塞直到它拿到锁。(共享资源每次只给一个线程使用，其他线程阻塞)。

##### 乐观锁

总是假设最好的情况，每次去拿数据都认为别人不会修改，所以不会上锁，但是在更新的时候会判断以下在此期间别人有人没有更新这个数据，可以使用版本号机制和CAS算法实现。客观锁适用于多读的应用类型，可以提高吞吐量。

版本号机制：数据每被修改一次，version都会加一，当线程A要更新数据值时，若刚才读到的version版本号和当前数据库中的version相等时才进行更新，否则重新尝试。

CAS算法（比较与交换），是一种无锁算法，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现临界资源的同步，所以也成为非阻塞同步。

CAS算法涉及到三个操作数：需要读写的内存值V，进行比较的值A，拟写入的新值V。

当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作(比较和替换是一个原子操作)。一般情况是一个自旋操作，即不断的重试。

乐观锁的问题：

- ABA问题：一个变量V初次读取的时候是A值，准备赋值的时候它仍然是A值，那我们也不能认为真没有别的线程修改过，因为可能它被修改为其他值，又被修改为A值，那么对于CAS操作来时就会认为他从来没有被修改过。
- 循环时间长开销大。因为使用自旋锁实现，不成功修改就会一直循环执行直到成功。
- 只能保证一个共享变量的原子操作。

##### 读写锁

由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。

所以，**读写锁适用于能明确区分读操作和写操作的场景**。

不管优先读锁还是写锁，对方可能会出现饿死问题，可以用公平锁解决，用队列把获取资源的线程排队。

##### 条件变量

可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的条件下进行的。

#### 信号量机制

无名信号量，用于线程间同步  sem_t sem;  

有名信号量(类似与管道)，用于进程间的同步或互斥，无名信号量直接保存在内存中，而有名信号量要求创建一个文件。

sem_t \*sem_open(const char* name, int flag, mode_t mode, usingned int value);  参数依次为文件名(不可为路径名，因为存放路径固定)、函数行为标志、文件权限、信号量初始值。

#### 信号机制

类似与进程间的信号处理。

#### 屏障

屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

### 线程池

初始化线程池,设定线程个数,请求队列大小,依次创建线程,传入回调函数参数(this指针,线程池指针,可以共享信号量,互斥锁等),并设置为线程分离.

调用append将任务加入请求队列,使用互斥锁,保证线程安全.加入队列后,对信号量V操作,告知有新的任务加入队列.

线程池运行函数,停止运行标志为假时,一直运行,首先执行信号量P操作,等待信号量通知,然后加锁获取队列中首个元素,弹出队首元素,解锁.执行任务处理函数,



http

向epoll添加文件描述符,设置水平触发, epolloneshot,避免正在读写操作,被后续到达的同一个文件描述符打断.设置文件描述符非阻塞

重置文件描述符 重置oneshot

设置端口复用

 //设置端口复用

  int reuse = 1;

  setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));

#### 线程池大小设定

计算(CPU)密集型：线程池数量设置等于CPU数量或+1 防止其他因素导致阻塞。    查看CPU内核个数**cat /proc/cpuinfo**

I/O密集型：根据密集类型，线程池数量设置为CPU1.5倍或更多  提高并发

任务优先级、任务执行长短。

高并发、任务执行时间短：少量线程数量。

并发不高，任务执行时间长：增加线程。

并发高，任务执行时间：业务解耦，拆解模块优化结构。

数量 =（（线程等待时间+线程CPU时间）／ 线程CPU时间）* CPU个数

## 四、Linux网络编程开发

### 常用命令

#### 查看网络相关命令

netstat

​	参数：

​		-a 所有的socket

​		-p 显示正在使用socket的程序的名称

​		-n 直接显示IP地址，而不通过域名服务器

​		-l 显示正在监听服务器的socket

​		-t 使用TCP的socket

​		-u 使用UDP的socket

### 端口



####  端口类型

1.常用端口 0~1023  (两个字节  0开头)

| FTP  | SSH/SCP | Telnet | SMTP | DNS  | HTTP | pop3 | HTTPS |
| ---- | ------- | ------ | ---- | ---- | ---- | ---- | ----- |
| 21   | 22      | 23     | 25   | 53   | 80   | 110  | 443   |

2.注册端口  1024~49151  (两个字节 10开头 1000 0000 0000 0000 ~ 1011 1111 1111 1111 )

3.私有端口/动态端口 49152~65535 (1100 0000 0000 0000 ~ 1111 1111 1111 11111)

#### SO_REUSEADDR/SO_REUSEPORT

##### SO_REUSEADDR套接字有以下功能：

- 允许启动一个监听服务器并捆绑其所周知的端口，即使以前建立的使用该端口的连接还存在。

  > 可以解决服务器重启时之前绑定的端口还未释放。
  >
  > 解决程序突然退出系统而没有释放端口。

- 允许同一端口上启动同一服务器的多个实例，只要每个实例绑定一个不同的本地IP即可。

  > 这种对IP别名技术托管多个HTTP服务器的网点是常见的。举例：本地主机主IP地址192.69.10.2，有198.69.10.128和198.69.10.129两个别名。在其上启动三个HTTP服务器，第一个HTTP服务器以本地通配IP地址INADDR_ANY和本地端口号80调用bind；第二个HTTP服务器以本地IP地址198.69.10.128和本地端口号80调用bind。这次调用将失败，除非设置了SO_REUSEADDR;第三个HTTP服务器与第二个同理。目的地址为192.69.10.128、目的端口号为80的外来TCP连接请求将交给第二个服务器。129将交给第三个，除此之外，所有端口号为80的其他TCP连接将地送给第一个服务器。`不可能启动多个端口和IP地址都相同的服务器`。为了安全起见，有些操作系统要求先启动具体地址的服务器(例如此处128、129)，执行通配地址捆绑的服务器最后一个启动。
  >
  > 多宿主机：具有多个IP层可见接口的主机。
  >
  > 主机可以把多个IP地址赋予给单个给定的物理接口。除第一个IP地址即主地址外的每个额外IP地址成为该接口的一个别名地址或逻辑接口地址。
  >
  > 常见端口这样绑定需要超级用户授权。

- 允许单个进程捆绑同一端口到多个套接字上。只要每次捆绑指定不同的本地IP地址即可。

  > 对UDP服务器是普遍的，对希望在一个多目的主机的若干个(而非全部)本地地址上服务连接的TCP服务器进程来说也需要采取这种方法。

- 支持完全重复的捆绑。

  > 这种仅支持UDP套接字。用于多播时，允许在同一个主机上同时运行同一个应用程序的多个副本。

端口复用允许在一个应用程序可以把 n 个套接字绑在一个端口上而不出错。同时，这 n 个套接字发送信息都正常，没有问题。但是，这些套接字并不是所有都能读取信息，只有最后一个套接字会正常接收数据。前提是UDP套接字。

在实际应用中，更新，老的程序执行之前的逻辑 等待执行完手动终止 新的程序接收新的请求

操作系统区分一个socket。采用五元组

<源IP、源端口、目的IP、目的端口、协议>

##### SO_REUSEPORT

并未重载SO_REUSEPORT所需的多播语义(即允许完全重复的捆绑)，而是引入一下语义：

- 本选项允许完全重复的捆绑，不过只有在想要捆绑同一IP地址和端口的每个套接字都指定了本套接字选项才可以。
- 如果被捆绑的IP地址是一个多播地址，那么两者时等效的。

需要注意的是，并未所有操作系统支持，可以改用SO_REUSEADDR。

SO_REUSEADDR有一个潜在的安全问题。 举例来说， 假设存在一个绑定了通配地址和端口5555的套接字，如果指定SO_ REUSEADDR， 我们就可以把相同的端口捆绑到不同的IP地址上，譬如说就是所在主机的主IP地址。此后目 的地为端口5555及新绑定IP地址的数据报将被递送到新的套接字，而不是递送到绑定 了通配地址的已有套接字。 这些数据报可以是TCP的SYN分节、SCTP的NIT块或UDP数据报。（UNIX网络编程习题11.9展示了UDP的这个特性。） 对于大多数众所周知的服务如HTTP、FTP和Telnet来说， 这不成问题， 因为这些服务器绑定的是保留端口。 这种情况下，后来的试图捆绑这些端口更为明确的实例（也就是盗用这些端口） 的任何进程都需要超级用户特权。然而NFS可能是一个问题， 因为它的通常端口（2049） 并不是保留端口。

### 网络协议

![image-20220403104041372](资料整理.assets/image-20220403104041372.png)



![image-20220403104909022](资料整理.assets/image-20220403104909022-16489541515781.png)

### socket通信

定义:网络上不主机上的应用程序之间双向通信的端点的抽象。打开open –> 读写write/read –> 关闭close”模式的一种实现。

常用类型：流式socket(SOCK_STREAM)和数据报socket(SOCK_DGRAM)。

网络中进程之间通过socket通信，利用三元组(ip地址、协议、端口)标识网络中唯一进程。



TCP三次握手发生在那些函数中：

![socket 中发送的 TCP 三次握手](https://camo.githubusercontent.com/acd13227ae0680f7d15aeec2189c61128115ff8f57c593a93b7af9db4282adef/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f736b796e65742f3230313031322f3230313031323132323135373436373235382e706e67)



#### 提高并发

- 基于线程，一个进程生成多个线程，每个线程去处理客服请求。线程池。
- 使用基于事件的模型，一个进程处理多个请求，通过epoll机制通知用户请求完成
- 支持磁盘的异步IO
- 支持mmp内存映射,直接读取磁盘内容。

### 字节序

小端字节序：数据的高位存储在高位地址，低位字节存储在内存的低位地址、

大端字节序：数据的低位存储在高位地址，高位字节存储在内存的低位地址、

#### 为什么存在大小端两种不同字节序

因为不同的各硬件厂商都认为自己采用的模式更优秀：

小端模式优点：

- 低地址放在低字节，在进行强制类型转换等处理任务时不需要调节字节内容。
- 做数值运算时，内存依次从低到高取数据进行计算，最后更新符号，运算更高效。

大端模式优点：符号在第一个字节中，可以快读判断正负大小。



### 服务器端 客户端TCP通信流程

![image-20220405152535252](资料整理.assets/image-20220405152535252-16491435416661.png)

### sockaddr和sockaddr_in

struct sockaddr和struct sockaddr_in这两个结构体用来处理网络通信的地址。 

socket（“套接字”），它是计算机之间进行**通信**的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。
而sockaddr就是保存socket中 网络协议、ip地址、端口号等信息。

sockaddr中的sa_data把目标地址和端口信息混在一起了。而sockaddr_in解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中。为了保持兼容，一般用sockaddr_in 进行复制保存，在传入connect函数时，强转指针类型就可以。

### shutdown 半关闭实现只读，不发送

只关闭socket描述符的读或者写。

如果多个进程共享一个套接字，每调用close()一次，计数减一，直到计数为0，套接字才被释放

而shoutdown 关闭读或者写后 所有相关进程不能读或者写。

### IO模型

这里主要指的是网络IO，服务器对于建立起多个客户端连接的读写。

- 阻塞blocking：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不断检查这个函数有没有返回，必须有返回值才能进行下一步。
- 非阻塞no-blocking：非阻塞等待，每隔一段时间就去检测IO事件是否就绪，没有就绪可以做其他事。
- IO复用：Linux使用select/poll/epoll函数实现I/O复用模型，这些函数也会使进程阻塞，但是和阻塞IO不同的是，这些函数可以同时阻塞多个IO操作。
- 信号驱动：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。
- 异步：Linux中可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，在通知应用程序。

#### 阻塞/非阻塞、同步/异步(网络IO)

典型一次IO的两个阶段：数据就绪、数据读写。

数据就绪：根据系统IO操作的就绪状态。

- 阻塞
- 非阻塞

数据读写：根据应用程序和内核的交互方式。同步是需要工作线程完成读，写以及任务处理等，而异步是读写等操作交给内核或其他进程，当前进程只关注任务处理。

- 同步
- 异步

在处理IO时，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO。

词义辨析：同步异步本质上形容的一种**流程**，没有特定的技术概念。而阻塞/非阻塞出处很明确，描述I/O接口的一个**特征**，即接口被调用后，在等待真正的结果返回之前，该进程是否会被挂起。 

在系统调用层面：

- 非阻塞I/O系统在于调用read()操作内核数据还没准备好时，用户进程在**一阶段数据准备时**是否会阻塞。

- 同 异步I/O系统调用read()，同步表示**第二阶段数据的读写**都是请求方自己来完成；异步表示**请求方并没有参与事件读写**

#### I/O多路复用(I/O多路转接)

定义：单个进程/线程可以监听多个文件描述符，一旦某个fd就绪，就可以进行相应操作，减少上下文切换的消耗，但是select、poll、epoll本质都是同步I/O，都需要在读写事件就绪后自己负责读写。 select、poll、epoll调用阻塞，socket非阻塞(默认阻塞)

##### [I/O复用 epoll select优缺点对比 区别](http://t.csdn.cn/EJeG4)

1. select

   流程：1.构建文件描述符列表(链表)，监听文件描述符加入列表中，并讲对应标志位 置1(表示要监听该fd)。 2.调用select将文件描述符列表拷贝到内核空间，轮询fd，阻塞等待，有IO操作时，内核将对应位置为1，并将结果返回用户空间。3. 用户空间遍历文件描述符列表，读取数据。

   缺点：

   - 每次调用select都需要在用户态和内核态之间拷贝监听文件描述符，开销很大。

   - 线性扫描，O(n)

   - 支持数量太小，默认只有1024（链表）

   - 监听文件文件描述符不能重用，每次要重置。
   - 每次调用 Select 都需要将进程加入到所有监视 Socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个监听socket列表数组传递给内核，有一定的开销。进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次。


2. poll

   解决了select使用pollfd结构(链表),解决了select支持数量太小的问题。

   缺点：大量拷贝，水平触发(当报告fd没有处理时会一直触发，耗费性能)。

3.epoll

同时支持ET、LT模式。前两者只支持LT模式。

- LT：只要事件没有处理完成会一直通知。

- ET：只有新的事件到达时，才会通知。

注意：使用ET模式，必须调用非阻塞接口，避免某事件在阻塞时将其他文件描述符饿死。三个重要接口：`epoll_create`, `epoll_ctl`, `epoll_wait`。

**LT适用于并发量小的情况，ET适用于并发量大的情况。**

ET在通知用户之后，就会将fd从就绪链表中删除，而LT不会，它会一直保留，这就会导致随着fd增多，就绪链表越大，每次都要从头开始遍历找到对应的fd，所以并发量越大效率越低。ET因为会删除所以效率比较高。

调用过程：

- 当调用epoll_wait函数时，会创建一个epoll对象，每个对象有一个结构体与之对应。

  结构体成员：

  - rbn，代表将要通过epoll_ctl向epoll对象中添加的事件，这些事件挂载在红黑树中，文件描述符信息。
  - rdlist，存放即将发生的事件，就绪列表。

- 文件fd状态改变，触发fd上的函数。

- 回调函数将响应的fd加入rdlist(就绪列表)，此时relist不为空，进程被唤醒，epoll_wait继续执行。

- 事件转移函数，将rdlist拷贝到epoll_wait函数的events参数。

- ep_send_events函数，它扫描txlist的每个数据，调用关联fd对应的poll方法去取fd中较新的事件，将取得的事件和对应的fd发送到用户空间。如果fd是LT模式的话，会被txlist的该数据重新放回rdlist，等待下一次继续触发调用。

优点：

- 没有最大并发连接的限制
- 只有活跃可用的fd才会调用callback函数
- 内存拷贝是利用mmap()文件映射内存的方式加速与内核空间的消息传递，减少复制开销。（内核与用户空间共享一块内存）
- 相对于select将添加等待队列(维护监视队列)、阻塞进程(监视的Socket)进行了分离，使用中监听的Socket相对固定。
- 监视队列(relist)使用双向链表，就绪socket队列(阻塞进程)使用红黑树。
- epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数。

只有存在大量的空闲连接和不活跃的连接的时候，使用epoll的效率才会比select/poll高

本身时间表就在内核空间，避免了相互拷贝问题。

在连接活跃，监听连接个数相对较少时，使用poll、select效率较高。



IO分两阶段：

> 1.数据准备阶段
>
> 2.内核空间复制回用户进程缓冲区阶段

一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。

在连接数少并且连接都十分活跃的情况下，select、poll性能更高。因为epoll有大量回调函数



select缺点：1。每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。3.select支持的文件描述符数量太小了，默认是1024。4.fds集合不能重用，每次都需要重置。

epoll效率高 1是内核共享内存，避免了多次拷贝。

#### epoll 

##### 使用

首先需要创建一个epollfd,需要使用epoll_creat函数去创建.

```cpp
#include<sys/epoll.h>
int epoll_creat(int size); //size已被弃用,传入大于0的值即可.
```

绑定添加一个fd或者删除一个fd,可以使用epoll_ctl函数:

```cpp
int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);
```

参数说明:

epfd即epollfd;  

op:操作类型,取值有EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL,分别表示添加,修改和删除一个fd.当取值是EPOLL_CTL_DEL时,第四个参数event忽略不计,可以设置为NULL.

参数fd即需要被操作的fd.

参数event,这是一个epoll_event结构体的地址.

红黑树 查找
链表

epoll两种模式ET,LT.

ET触发情况

- 读
  - buffer由不可读变为可读,即空变为不空的时候.
  - 有新的数据到达,即buffer中数据变多的时候.

- 写
  - buffer由不可写变为可写的时候,即buffer由满状态变为不满的时候.
  - 当由旧数据发送走,buffer中待写的内容变少的时候.



epoll_server 使用 ET 模式下即使给客户端 fd 注册了检测可写事件不会一直触发，只会触发一次，触发完后只有再次注册检测可写事件才会继续触发，这里是靠客户端来新消息驱动再次注册检测可写事件。也就是说，如果我们使用 ET 模式去处理可写事件时不必像 LT 模式那样为了避免不必要的可写触发在触发后需要立即移除检测可写事件。

这就意味着，使用 LT 模式，如果你的实现依赖于可写事件触发去发送数据，那么你一定要在数据发送完之后移除检测可写事件，避免没有数据发送时无意义的触发；使用 ET 模式时，如果你的实现也依赖于可写事件触发去发送数据，可写事件触发后，你调用 send 函数（Linux 平台也可以使用 write）去发送数据，如果数据本次不能全部发送完（对于非阻塞的 socket，此时 send 函数返回 -1，错误码为 EAGAIN 或 EWOULDBLOCK），你一定要继续注册检测可写事件，否则你剩余的数据就再也没有机会发送了，因为 ET 模式的可写事件再也不会触发。

> 在目前主流的网络库中，发数据的逻辑都不是上面所说的依赖于写事件触发，在写事件触发时去发数据。这种做法不好，那好的做法是什么呢？我会在后续文章《收数据与发数据的正确做法》中详细介绍。

最后容我再啰嗦几句，总结起来：

- LT 模式下，读事件触发后，可以按需收取想要的字节数，不用把本次接收到的数据收取干净（即不用循环到 recv 或者 read 函数返回 -1，错误码为 EWOULDBLOCK 或 EAGAIN）；ET 模式下，读事件必须把数据收取干净，因为你不一定有下一次机会再收取数据了，即使有机会，也可能存在上次没读完的数据没有及时处理，造成客户端响应延迟。
- LT 模式下，不需要写事件一定要及时移除，避免不必要的触发，浪费 CPU 资源；ET 模式下，写事件触发后，如果还需要下一次的写事件触发来驱动任务（例如发上次剩余的数据），你需要继续注册一次检测可写事件。

#### epoll的线程安全

**简要结论就是epoll是通过锁来保证线程安全的, epoll中粒度最小的自旋锁ep->lock(spinlock)用来保护就绪的队列, 互斥锁ep->mtx用来保护epoll的重要数据结构红黑树**

### 整体流程

```cpp
//简略版
//创建一个用于监听的socket
int listenfd = socket(AF_INET, SOCK_STREAM, 0);
//设置端口复用
setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT, &reuse, sizeof(reuse)); //reuse = 1;
//将监听设置为非阻塞的
fcntl(listenfd, F_SETFL, newSocketFlag); // newSocketFlag = oldSocketFlag | O_NONBLOCK;
//初始化服务器地址 并绑定
bind(listenfd, (struct sockaddr*)& binaddr, sizeof(binaddr));
//启动监听
listen(listenfd, SOMAXCONN);
//创建epoll  并初始化加入listenfd,设置EPOLLIN
int epollfd = epoll_create(1);
epoll_event listen_fd_event; //.data.fd = listenda  .events = EPOLLIN
//将监听socket绑定到epollfd上去
epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &listen_fd_event);
//初始化完成,进入循环处理
epoll_wait(epollfd, epoll_events, 1024, 1000); // 根据返回值判断是新连接还是 新数据到达
```

### 高并发

1. HTML静态化 使用CMS(信息管理系统)，
2. 图片服务器分离  图床
3. 数据库集群和库表散列   当数据增加到100万以上，那么，MySQL的效能急剧下降。常用的优化措施是M-S（主-从）方式进行同步复制，将查询和操作和分别在不同的服务器上进行操作。推荐的是M-M-Slaves方式，2个主Mysql，多个Slaves，需要注意的是，虽然有2个Master，但是同时只有1个是Active，我们可以在一定时候切换。之所以用2个M，是保证M不会又成为系统的SPOF。
4. 缓存  客户端缓存
5. 镜像
6. 负载均衡

### list_head(双向链表)

#### 定义:

```cpp
struct list_head{ //位于 kernel/include/linux/types.h
	struct list_head *next, *prev;
}
```

#### 创建列表

##### 内核提供了以下接口来初始化链表:

```cpp
#define LIST_HEAD_INIT(name) {&(name), &(name)}
#define LIST_HEAD(name) \                        //代表此行未完 本行与下一行连接起来
		struct list_head name = LIST_HEAD_INIT(name)
static inline void INIT_LIST_HEAD(struct list_head *list){
	WRITE_ONCE(list->next, list); //WRITE_ONCE 保证在多线程下被其他函数调用变量是不会出错 使用了volatile
            list->prev = list;
}
```

通过以提供的LIST_HEAD(mylist)进行初始化一个链表,mylist的prev,next都指向自己.

```cpp
struct list_head mylist = {&mylist, &mylist};  //使用LIST_HEAD(mylist)等同于这句
```

此时仅有指向自己的一个结点,在使用中,我们一般创建一个宿主结构,包含了其他数据,并再嵌套mylist字段.

```cpp
struct my_task_list{
	int val;
    struct list_head mylist;
}
```

##### 创建第一个节点

```cpp
struct my_task_list first_task = {
    .val = 1,
    .mylist = LIST_HEAD_INIT(fitst_task.mylist)
};
```

##### 添加节点

###### list_add

作用:在链表head后方插入一个新节点new. 可利用实现堆栈.

```cpp
static inline void list_add(struct list_head *new, struct list_head *head){
	__list_add(new, head, head->next);
}
```

由上可见list_add再调用__list_add接口,定义如下:

```cpp
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next){
    if(!__list_add_valid(new, prev, next))
        return;
    next->prev = new;
    new->next = next;
    new->prev = prev;
    WRITE_ONCE(prev->next, new);
}
```

具体创建使用:

```cpp
LIST_HEAD(header_task);  //创建表头
struct my_list_head my_first_task = {  //创建实际的第一个节点
    .val = 1,
    .mylist = LIST_HEAD_INIT(my_first_task.mylist)
};
list_add(&my_first_task.mylist, &header_task); //节点插入到header_task和第一个节点之间
//另一种初始化方式
struct my_task_list my_second_task;
my_second_task.val =1;
INIT_LIST_HEAD(&my_first_task.mylist);
```

###### list_add_tail

内核也提供了从链表尾部向前添加节点的接口,实现如下: (适用于实现双端队列)

```cpp
static inline void list_add_tail(struct list_head *new, struct list_head *head){
	__list_add(new, head_prev, head);
}
```

不断向表尾插入元素,那么第一个插入的元素就是头结点的下一个元素,实现了队列(先进先出).

###### list_del 删除节点

```cpp
static inline void list_del(struct list_head &entry){
    __list_del_entry(entry);
    entry->next = LIST_POISON1;  //LIST_POISON1/2是不能访问地址,此处意为指向不能访问的地址,强制删除这两个指针,如果使用就会报错.
    entry->prev = LIST_POISON2;
}

static inline void __list_del_entry(struct list_head *entry){
    if(!__list_del_entry_valid(entry))
        return;
    __list_del(entry->prev, entry->next);
}

static inline void __list_del(struct list_head *prev, struct list_head *next){
	next->prev = prev;
    WRITE_ONCE(prev->next, next);
}
//前提条件:被删除节点是已知的,即在链表中真实存在的,且prev,next指针都不为NULL;
```

###### 链表遍历

通过宏定义实现

```cpp
#define list_for_each(pos, head) for(pos = (head)->next; pos != head; pos = pos->next)
//上面是从前往后遍历,也可以从后往前遍历
#define list_for_each_prev(pos, head) for(pos = (head)->prev; pos != head;)
```

list.h 中也提供了list_replace( 节点替换) list_move(节点移位) ，翻转，查找等接口

那我们如何根据mylist这个字段的地址而找到宿主结构my_task_list的位置呢？？？

```cpp
container_of(ptr, type, member)

#define list_entry(ptr, type, member) container_of(ptr, type, member)

#define container_of(ptr, type, member) ({          \  
    const typeof( ((type *)0)->member ) *__mptr = (ptr); \  
    (type *)( (char *)__mptr - offsetof(type,member) );}) 
    
```

[看下container_of宏的注释：](https://blog.csdn.net/wanshilun/article/details/79747710)

（1）根据结构体重的一个成员变量地址导出包含这个成员变量mem的struct地址。

（2）参数解释：

​    ptr  ： 成员变量mem的地址    

​    type： 包含成员变量mem的宿主结构体的类型

​    member： 在宿主结构中的mem成员变量的名称

   

### 笔试整理

- 设备类型：

  字符设备：提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按字节/字符来读写数据。举例来说，键盘、串口、调制解调器都是典型的字符设备。

  块设备：应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘、软盘、CD-ROM驱动器和闪存都是典型的块设备，应用程序可以寻址磁盘上的任何位置，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。

- 命令

  在DOS中有一个命令是pause，作用是输出提示信息“Press any key to continue...”，然后任意按下一个键继续运行。

  Linux中没有pause，需要自己实现。

  cat命令是连接文件或标准输入并打印。这个命令通常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示。他常与重定向符号配合使用。cat主要三大功能：1.一次显示整个文件：cat filename。 2.从键盘创建一个文件：cat > filename 只能创建新文件，不能编辑已有文件。 3.将几个文件合并为一个文件：cat file1 file2 > file.

  more命令类似于cat，cat是整个文件从上到下显示在屏幕，more是一页一页的显示方便使用者逐页阅读，空格(sapce)下一页，b键会往回一页显示。还可以从前往后搜索，因此启动时加载整个文件。

  grep命令是一种强大的文本搜索工具，能使用正则表达式搜索文本，并把匹配的行打印出来。各种查找命令(find,grep,which,whereis,locate)。

- 了解当前目录多大空间

  use df:列出指定的每一个文件名所在的文件系统上可用的磁盘数量，如果没有指定，则现实当前所有使用中的文件系统。use du:报告磁盘使用空间。(use du/  主目录；   use du. 当前目录)

- 更改文件的权限设置

  chmod

- 删除用户并同时删除用户的主目录  userdel -r

- crontab 在周一至周五下午一点和八点各运行一次备份程序mybackup。  0 13,20**1,5 mybackup

- 启动应用程序时，设置进程的优先级： nice

- 将f1.txt复制为f2.txt cp f1.txt f2.txt(使用cp复制目录 必须加-r)、 cat f1.txt->f2.txt

- 显示一个文件最后几行 tail

- 快速切换到用户john的主目录下  cd ~john

- tr命令 "tr string1 string2"  string1用于查询，string2 用于处理各种转换

  tr a-z A-Z 将所有小写转化为大写

  cat file | tr "abc" "xyz" > new_file 凡是在file中出现的"a"字母，都替换成"x"字母，"b"字母替换为"y"字母，"c"字母替换为"z"字母。而不是将字符串"abc"替换为字符串"xyz"。

- 正则表达式

  在文件中查找所有以'*'开头的行， grep '^\*' file

- kill 9 含义 sends SIGTERM to the process whose PID IS 9.

- iptables 提供tcp/ip包过滤

- 操作tgz  解压缩   tar zxvf filename.tgz -C ./
           压缩  tar -zcvf filename.tar 被压缩文件名

  必选其中之一

  -c: 建立压缩档案
  -x：解压
  -t：查看内容
  -r：向压缩归档文件末尾追加文件
  -u：更新原压缩包中的文件

  可选

  -z：有gzip属性的
  -j：有bz2属性的
  -Z：有compress属性的
  -v：显示所有过程
  -O：将文件解开到标准输出      

    -f是必须的， 使用档案名字，这个参数是最后一个参数，后面只能接档案名。
