/*
    题目描述:
    有n件衣服从左到右成一行排列，所在位置分别为1~n， 在每个位置上已经有一个就绪的机器人可以帮忙收衣服，但第i个位置上的机器人需要Pi的电量来启动， 
    然后这个机器人会用ti的时间收衣服，当它收完当前衣服后， 会尝试去收紧邻的右边的一件衣服(如果存在的话)， 即i+1处的衣服，
    如果i+1 处的衣服已经被其他机器人收了或者其他机器人正在收， 这个机器人就会进入休眠状态,不再收衣服。
    不过如果机器人没有休眠，它会同样以ti时间来收这件i+1处的衣服(注意，不是t(i+1)的时间，收衣服的时间为每个机器人固有属性)， 
    然后它会做同样的检测来看能否继续收i+2 处的衣服，一直直到它进入休眠状态或者右边没有衣服可以收了。形象地来说，机器人会一直尝试往右边收衣服，
    收k件的话就耗费k*t的时间，但是当它遇见其他机器人工作的痕迹，就会认为后面的事情它不用管了，开始摸鱼，进入休眠状态。
    小团手里总共有电量b，他准备在0时刻的时候将所有他想启动的机器人全部一起启动，过后不再启动新的机器人， 并且启动的机器人的电量之和不大于b。
    他想知道在最佳选择的情况下，最快多久能收完衣服。若无论如何怎样都收不完衣服， 输出-1。
    输入描述
    第一行两个正整数n和b，分别表示衣服数量和小团持有电量。
    接下来一行n个数P1,P2...,Pn，含义如题所述，为机器人唤醒需求电量。 
    接下来一行n个数t1,t2...,tn 为机器人收衣服所需时间。 
    数字间两两有空格隔开。
    对于所有数据，1≤n≤1000，1≤pi≤100,1≤ti,b≤1e5
    输出描述
    输出收衣服所需最短时间。
    样例输入
    3 5
    1 2 3
    7 5 3
    样例输出
    10
    提示
    可以同时启动第一个机器人和第二个机器人， 耗电量为1+2=3，这样花费时间为max(7,5*2)=10。
    也可以同时启动第一个机器人和第三个机器人， 耗电量为1+3=4，这样花费时间为max(7*2,3)=14。所以答案为10
    输入样例2
    3 5
    6 2 3
    7 5 3
    输出样例2
    -1
    样例解释：必须启动第一个机器人，耗电量为6，而持电量为5，所以无法完成。
*/

#include<iostream>
#include<vector>
using namespace std;

int main(){
    int n, b;
    cin >> n >> b;
    vector<int> p(n + 1);
    for(int i = 1; i <= n; ++i)
        cin >> p[i];
    vector<int> t(n + 1);
    for(int i = 1; i <= n; ++i)
        cin >> t[i];
    if(p[1] > b){
        cout << -1; return 0;
    }
    int l = 1, r = 1e9, ret = 1e9;
    auto check = [&](int mid) -> bool{  //[外部变量访问方式说明符] (参数表) -> 返回值类型 {语句块} 其中，“外部变量访问方式说明符”可以是=或&，
    //表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&表示允许。“-> 返回值类型”可以省略。
        vector<int> dp(n + 2, 1e9);
        dp[n + 1] = 0;  //由后往前，一维数组即可保存当前位置到最后所需最小电量
        for(int i = n; i >= 1; --i){
            for(int j = n + 1; j > i; --j){
                if(t[i] * (j - i) <= mid){
                    dp[i] = min(dp[i], dp[j] + p[i]);
                }
            }
        }
        return dp[1] <= b;
    };
    //由大到小去尝试给定时间内，满足要求的最小电量是否小于给定电量
    while(l <= r){
        int mid = (l + r) / 2;
        if(check(mid)){
            ret = mid;
            r = mid - 1;
        }else l = mid + 1;

    }
    cout << ret << endl;
    return 0;
}


